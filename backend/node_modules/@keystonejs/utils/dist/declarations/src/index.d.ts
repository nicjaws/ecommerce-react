import pLazy from 'p-lazy';
import semver from 'semver';
export declare const noop: <T>(x: T) => T;
export declare const identity: <T>(x: T) => T;
export declare const getType: (thing: any) => string;
export declare const escapeRegExp: (str: string) => string;
export declare const mapKeys: <T, R>(obj: T, func: (value: T[keyof T], key: keyof T, obj: T) => R) => Record<keyof T, R>;
export declare const mapKeyNames: <T, R extends string>(obj: T, func: (key: keyof T, value: T[keyof T], obj: T) => R) => Record<R, T[keyof T]>;
declare type Await<TPromise extends Promise<any>> = TPromise extends Promise<infer Value> ? Value : never;
export declare const resolveAllKeys: <T extends Record<string, Promise<any>>>(obj: T) => Promise<{ [KK in keyof T]: Await<T[KK]>; }>;
export declare const unique: <T>(arr: T[]) => T[];
export declare const intersection: <T>(array1: T[], array2: T[]) => T[];
export declare const pick: <T, K extends keyof T>(obj: T, keys: K[]) => { [P in K]: T[P]; };
export declare const omitBy: <T>(obj: T, func: (key: keyof T) => boolean) => Partial<T>;
export declare const omit: <T, K extends keyof T>(obj: T, keys: K[]) => Pick<T, Exclude<keyof T, K>>;
declare type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;
export declare const objMerge: <T extends any[]>(objs: [...T]) => UnionToIntersection<T[number]>;
export declare const defaultObj: <T, K extends string>(keys: K[], val: T) => Record<K, T>;
export declare const filterValues: <T>(obj: T, predicate: (value: T[keyof T]) => boolean) => Partial<T>;
/**
 * Given an array of objects, returns a single new object keyed by a given property of each input object
 * and transformed by a given function.
 *
 * @example [x, y, z] => { x[keyedBy]: mapFn(x), ... }
 * @example
 * arrayToObject([
 *  { name: 'a', animal: 'cat' },
 *  { name: 'b', animal: 'dog' },
 *  { name: 'c', animal: 'cat' },
 *  { name: 'd', animal: 'dog' }
 * ], 'name', o => o.animal);
 *
 * // Would give
 * {
 *   a: 'cat',
 *   b: 'dog',
 *   c: 'cat',
 *   d: 'dog'
 * }
 *
 * @param {Object} objs An array of objects. These should have the same properties.
 * @param {String} keyedBy The property on the input objects to key the result.
 * @param {Function} mapFn A function returning the output object values. Takes each full input object.
 */
export declare const arrayToObject: <V extends string, T extends Record<string, V>, R>(objs: T[], keyedBy: keyof T, mapFn?: (a: T) => R) => Record<V, R>;
/**
 * Concatenates child arrays one level deep.
 * @example flatten([[1, 2, 3], [4, 5], 6, [[7, 8], [9, 10]]]) => [1, 2, 3, 4, 5, 6, [7, 8], [9, 10]]
 * @param {Array} arr An array of one or more arrays
 * @returns The new array.
 */
export declare const flatten: <T>(arr: T[][]) => any[];
export declare const flatMap: <T, U>(arr: T[], fn: (a: T) => U[]) => any[];
export declare const zipObj: <V, T extends Record<string, V[]>>(obj: T) => Record<keyof T, V>[];
export declare const compose: <T>(fns: ((a: T) => T)[]) => (o: T) => T;
export declare const mergeWhereClause: (queryArgs: Record<string, any>, whereClauseToMergeIn: Record<string, any>) => Record<string, any>;
export declare const createLazyDeferred: <T, S>() => {
    promise: pLazy<unknown>;
    resolve: (val: T) => void;
    reject: (error: S) => void;
};
/**
 * Given an array of functions which may throw a Promise when executed, we want
 * to ensure all functions are executed, reducing any thrown Promises to a
 * single Promise, which is itself rethrown.
 * If no Promises are thrown, this is the equivalent of a .map
 * @param {Array} executors
 */
export declare const captureSuspensePromises: <T>(executors: (() => T)[]) => T[];
/**
 * Returns the length of all arrays in obj
 * @param {*} obj An objects whose property values are arrays.
 */
export declare const countArrays: (obj: Record<string, any[]>) => number;
/**
 * Compares two version strings or number arrays in the major.minor.patch format.
 * @param {Array<Number>|String} comp The version to compare.
 * @param {Array<Number>|String} base The version against which to compare.
 * @returns True if each element of comp is greater than or equal base.
 */
export declare const versionGreaterOrEqualTo: (comp: Parameters<typeof semver.coerce>[0], base: Parameters<typeof semver.coerce>[0]) => boolean;
/**
 * Converts the first character of a string to uppercase.
 * @param {String} str The string to convert.
 * @returns The new string
 */
export declare const upcase: (str: string) => string;
/**
 * Iteratively execute a callback against each item in an array.
 * @param {Array} array An array of items.
 * @param {Function} callback A callback function returning a promise.
 */
export declare const asyncForEach: <T>(array: T[], callback: (item: T, index: number, array: T[]) => Promise<void>) => Promise<void>;
export {};
