'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var core = require('@emotion/core');
var React = require('react');
var _extends = require('@babel/runtime/helpers/extends');
var index = require('../../../../../dist/index-ff4b1f2a.cjs.prod.js');
var reactPopper = require('react-popper');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _objectWithoutProperties__default = /*#__PURE__*/_interopDefault(_objectWithoutProperties);
var _extends__default = /*#__PURE__*/_interopDefault(_extends);

const PopperRender = /*#__PURE__*/React.forwardRef(({
  update,
  alignment,
  isFocused,
  style,
  onAlignmentChange
}, ref) => {
  React.useLayoutEffect(() => {
    // The update function is `null` on first render - we want to update this after the below component is mounted to have the correct handler
    if (update) update();
  }, [alignment, update]);
  return core.jsx("div", {
    ref: ref,
    css: {
      display: isFocused ? 'block' : 'none',
      backgroundColor: 'black',
      padding: 8
    },
    style: style
  }, ['left', 'center', 'right'].map(align => {
    return core.jsx("button", {
      type: "button",
      key: align,
      onMouseDown: event => {
        // so that the image block doesn't get deselected
        event.preventDefault();
      },
      onClick: () => {
        onAlignmentChange(align);
      }
    }, align);
  }));
});
const popperModifiers = [{
  name: 'flip',
  enabled: false
}, {
  name: 'hide',
  enabled: false
}, {
  name: 'preventOverflow',
  enabled: false
}];

const Image = (_ref) => {
  let {
    alignment,
    attributes,
    isFocused,
    src,
    onAlignmentChange
  } = _ref,
      props = _objectWithoutProperties__default['default'](_ref, ["alignment", "attributes", "isFocused", "src", "onAlignmentChange"]);

  const [referenceElement, setReferenceElement] = index.useStateWithEqualityCheck(null);
  const [popperElement, setPopperElement] = React.useState(null);
  const {
    styles,
    update
  } = reactPopper.usePopper(referenceElement, popperElement, {
    placement: 'top',
    modifiers: popperModifiers
  });
  return core.jsx("div", null, core.jsx("img", _extends__default['default']({}, props, attributes, {
    src: src,
    ref: setReferenceElement,
    css: {
      width: '100%',
      outline: isFocused ? 'auto' : null
    }
  })), core.jsx(PopperRender, {
    update,
    alignment,
    ref: setPopperElement,
    isFocused,
    style: styles.popper,
    onAlignmentChange
  }));
};

/** @jsx jsx */
let type = 'image';
let ImageAlignmentContext = /*#__PURE__*/React.createContext({
  aligment: '',

  onAlignmentChange() {}

});
function Node(props) {
  let {
    data
  } = props.node;
  let {
    aligment,
    onAlignmentChange
  } = React.useContext(ImageAlignmentContext);
  return core.jsx(Image, {
    alignment: aligment,
    attributes: props.attributes,
    isFocused: props.isFocused,
    src: data.get('src'),
    onAlignmentChange: onAlignmentChange
  });
}
let getSchema = () => ({
  isVoid: true
});

exports.ImageAlignmentContext = ImageAlignmentContext;
exports.Node = Node;
exports.getSchema = getSchema;
exports.type = type;
