'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var objectSpread2 = require('../../../dist/objectSpread2-a7e51403.cjs.dev.js');
var utils = require('@keystonejs/utils');
require('../../../dist/slate-walker-bf7ae930.cjs.dev.js');
var slate = require('slate');
require('nanoassert');
var slateSerializer_dist_fieldsContent = require('../../../slate-serializer/dist/fields-content.cjs.dev.js');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var memoizeOne = require('memoize-one');
var isPromise = require('p-is-promise');
var Controller = require('@keystonejs/fields/Controller');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _objectWithoutProperties__default = /*#__PURE__*/_interopDefault(_objectWithoutProperties);
var _defineProperty__default = /*#__PURE__*/_interopDefault(_defineProperty);
var memoizeOne__default = /*#__PURE__*/_interopDefault(memoizeOne);
var isPromise__default = /*#__PURE__*/_interopDefault(isPromise);
var Controller__default = /*#__PURE__*/_interopDefault(Controller);

const initialValue = {
  document: {
    nodes: [{
      object: 'block',
      type: 'paragraph',
      nodes: [{
        object: 'text',
        text: ''
      }]
    }]
  }
};

const flattenBlocks = inputBlocks => inputBlocks.reduce((outputBlocks, block) => {
  if (!block.type) {
    // Some blocks may pull in other views which aren't themselves blocks, so
    // we ignore them here
    return outputBlocks;
  } // NOTE: It's enough to check just the type here as we've already flattened
  // and deduped dependencies during build.


  if (outputBlocks[block.type]) {
    throw new Error(`Encountered more than one Content block with type of '${block.type}'. Content blocks must have globally unique types.`);
  }

  if (block.Node === undefined) {
    throw new Error(`Unable to load Content block '${block.type}': no 'Node' export found.`);
  }

  outputBlocks[block.type] = block;
  return outputBlocks;
}, {});

class ContentController extends Controller__default['default'] {
  constructor(_ref, ...args) {
    let {
      defaultValue = slate.Value.fromJSON(initialValue)
    } = _ref,
        config = _objectWithoutProperties__default['default'](_ref, ["defaultValue"]);

    super(objectSpread2._objectSpread2(objectSpread2._objectSpread2({}, config), {}, {
      defaultValue
    }), ...args); // Attach this as a memoized member function to avoid two pitfalls;
    // 1. Don't load all the block views up front. Instead, lazily load them
    //    only when requested.
    // 2. Avoid recalculating everything on each request for the Blocks.
    //    Instead, when requested multiple times, use the previously cached
    //    results.
    // NOTE: This function is designed to work with React Suspense, so may throw
    // a Promise the first time it is called.

    _defineProperty__default['default'](this, "getFilterGraphQL", ({
      type,
      value
    }) => {
      const key = type === 'is' ? `${this.path}` : `${this.path}_${type}`;
      return {
        [key]: value
      };
    });

    _defineProperty__default['default'](this, "getFilterLabel", ({
      label
    }) => {
      return `${this.label} ${label.toLowerCase()}`;
    });

    _defineProperty__default['default'](this, "formatFilter", ({
      label,
      value
    }) => {
      return `${this.getFilterLabel({
        label
      })}: "${value}"`;
    });

    _defineProperty__default['default'](this, "getFilterTypes", () => [{
      type: 'contains',
      label: 'Contains',
      getInitialValue: () => ''
    }, {
      type: 'not_contains',
      label: 'Does not contain',
      getInitialValue: () => ''
    }]);

    _defineProperty__default['default'](this, "getBlocksSync", () => {
      // May return synchronously, or may throw with either an actual error or a
      // loading promise. We should never see a Promise thrown as .serialize()
      // only gets called during event handlers on the client _after_ all the
      // React Suspense calls are fully resolved. We want the
      // returns-synchronously case. Otherwise, we want to either rethrow any
      // error thrown, or throw a new error indicating an unexpected Promise was
      // thrown.
      try {
        return this.getBlocks();
      } catch (loadingPromiseOrError) {
        if (isPromise__default['default'](loadingPromiseOrError)) {
          // `.getBlocks()` thinks it's in React Suspense mode, which we can't
          // handle here, so we throw a new error.
          throw new Error('`Content#getBlocks()` threw a Promise. This may occur when calling `Content#(de)serialize()` before blocks have had a chance to fully load.');
        } // An actual error occurred


        throw loadingPromiseOrError;
      }
    });

    _defineProperty__default['default'](this, "serialize", data => {
      const {
        path
      } = this;

      if (!data[path] || !data[path].document) {
        // Forcibly return null if empty string
        return {
          document: null
        };
      }

      const blocks = this.getBlocksSync();
      const serializedDocument = slateSerializer_dist_fieldsContent.serialize(data[path], blocks); // TODO: Make this a JSON type in GraphQL so we don't have to stringify it.

      serializedDocument.document = JSON.stringify(serializedDocument.document);
      return {
        disconnectAll: true,
        create: serializedDocument
      };
    });

    _defineProperty__default['default'](this, "deserialize", data => {
      const {
        path
      } = this;

      if (!data[path] || !data[path].document) {
        // Forcibly return a default value if nothing set
        return slate.Value.fromJSON(initialValue);
      }

      const blocks = this.getBlocksSync(); // TODO: Make the .document a JSON type in GraphQL so we don't have to parse
      // it

      const parsedData = objectSpread2._objectSpread2(objectSpread2._objectSpread2({}, data[path]), {}, {
        document: JSON.parse(data[path].document)
      }); // Filter out oEmbeds from parsedData.document that missing from parsedData.oEmbeds


      parsedData.document.nodes = parsedData.document.nodes.filter(node => {
        if (node.type !== 'oEmbed') {
          return true;
        }

        if (!node.data || !node.data._joinIds || !node.data._joinIds.length) {
          return false;
        }

        return parsedData.oEmbeds.find(embed => embed.id === node.data._joinIds[0]);
      });
      return slateSerializer_dist_fieldsContent.deserialize(parsedData, blocks);
    });

    _defineProperty__default['default'](this, "getQueryFragment", () => `
    ${this.path} {
      document
      ${Object.values(this.config.blockOptions).map(({
      query
    }) => query).filter(Boolean).join('\n')}
    }
  `);

    _defineProperty__default['default'](this, "initFieldView", () => {
      utils.captureSuspensePromises([() => {
        const {
          Field
        } = this.views;

        if (Field) {
          this.readViews([Field]);
        }
      }, () => this.getBlocks()]);
    });

    _defineProperty__default['default'](this, "initCellView", () => {
      utils.captureSuspensePromises([() => {
        const {
          Cell
        } = this.views;

        if (Cell) {
          this.readViews([Cell]);
        }
      }, () => this.getBlocks()]);
    });

    _defineProperty__default['default'](this, "initFilterView", () => {
      utils.captureSuspensePromises([() => {
        const {
          Filter
        } = this.views;

        if (Filter) {
          this.readViews([Filter]);
        }
      }, () => this.getBlocks()]);
    });

    this.getBlocks = memoizeOne__default['default'](() => {
      // Loads all configured blocks and their dependencies
      const blocksModules = this.readViews(this.views.blocks);
      const customBlocks = blocksModules.map(block => objectSpread2._objectSpread2(objectSpread2._objectSpread2({}, block), {}, {
        options: objectSpread2._objectSpread2(objectSpread2._objectSpread2({}, this.config.blockOptions[block.type]), {}, {
          readViews: this.readViews
        }),
        // This block exists because it was passed into the Content field
        // directly.
        // Dependencies are not allowed to show UI chrome (toolbar/sidebar) unless
        // they're also directly passed to the Content Field.
        withChrome: this.config.blockTypes.includes(block.type)
      }));
      return flattenBlocks(customBlocks);
    });
  }

}

exports.default = ContentController;
