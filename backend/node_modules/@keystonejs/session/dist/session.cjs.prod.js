'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var cookieSignature = require('cookie-signature');
var expressSession = require('express-session');
var cookie = require('cookie');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _defineProperty__default = /*#__PURE__*/_interopDefault(_defineProperty);
var cookieSignature__default = /*#__PURE__*/_interopDefault(cookieSignature);
var expressSession__default = /*#__PURE__*/_interopDefault(expressSession);
var cookie__default = /*#__PURE__*/_interopDefault(cookie);

class SessionManager {
  constructor({
    cookieSecret,
    cookie,
    sessionStore
  }) {
    _defineProperty__default['default'](this, "_cookieSecret", void 0);

    _defineProperty__default['default'](this, "_cookie", void 0);

    _defineProperty__default['default'](this, "_sessionStore", void 0);

    if (!cookieSecret) {
      {
        throw new Error('The cookieSecret config option is required when running Keystone in a production environment. Update your app or environment config so this value is supplied to the Keystone constructor. See [https://www.keystonejs.com/keystonejs/keystone/#cookiesecret] for details.');
      }
    }

    this._cookieSecret = cookieSecret;
    this._cookie = cookie;
    this._sessionStore = sessionStore;
  }

  getSessionMiddleware({
    keystone
  }) {
    const COOKIE_NAME = 'keystone.sid'; // We have at least one auth strategy
    // Setup the session as the very first thing.
    // The way express works, the `req.session` (and, really, anything added
    // to `req`) will be available to all sub `express()` instances.
    // This way, we have one global setting for authentication / sessions that
    // all routes on the server can utilize.

    const injectAuthCookieMiddleware = (req, res, next) => {
      if (!req.headers) {
        return next();
      }

      let authHeader = req.headers.authorization || req.headers.Authorization;

      if (!authHeader) {
        return next();
      }

      if (Array.isArray(authHeader)) {
        authHeader = authHeader[0];
      }

      const [type, token] = authHeader.split(' ');

      if (type !== 'Bearer') {
        // TODO: Use logger
        console.warn(`Got Authorization header of type ${type}, but expected Bearer`);
        return next();
      } // Split the cookies out


      const cookies = cookie__default['default'].parse(req.headers.cookie || ''); // Construct a "fake" session cookie based on the authorization token

      cookies[COOKIE_NAME] = `s:${token}`; // Then reset the cookies so the session middleware can read it.

      req.headers.cookie = Object.entries(cookies).map(([name, value]) => `${name}=${value}`).join('; '); // Always call next

      next();
    };

    const sessionMiddleware = expressSession__default['default']({
      secret: this._cookieSecret,
      resave: false,
      saveUninitialized: false,
      name: COOKIE_NAME,
      cookie: this._cookie,
      store: this._sessionStore
    });

    const _populateAuthedItemMiddleware = async (req, res, next) => {
      const item = await this._getAuthedItem(req, keystone);

      if (!item) {
        // TODO: probably destroy the session
        return next();
      }

      req.user = item;
      req.authedListKey = req.session.keystoneListKey;
      next();
    };

    return [injectAuthCookieMiddleware, sessionMiddleware, _populateAuthedItemMiddleware];
  }

  async _getAuthedItem(req, keystone) {
    const session = req.session;

    if (!session || !session.keystoneItemId) {
      return;
    }

    const list = keystone.lists[session.keystoneListKey];

    if (!list) {
      return;
    }

    let item;

    try {
      item = (await list.adapter.itemsQuery({
        where: {
          id: session.keystoneItemId
        }
      }))[0];
    } catch (e) {
      return;
    }

    if (!item) {
      return;
    }

    return item;
  }

  startAuthedSession(req, {
    item,
    list
  }) {
    return new Promise((resolve, reject) => req.session.regenerate(err => {
      if (err) return reject(err);
      req.session.keystoneListKey = list.key;
      req.session.keystoneItemId = item.id;
      resolve(cookieSignature__default['default'].sign(req.session.id, this._cookieSecret));
    }));
  }

  endAuthedSession(req) {
    const {
      keystoneListKey,
      keystoneItemId
    } = req.session || {};
    return new Promise((resolve, reject) => req.session.regenerate(err => {
      if (err) return reject(err);
      resolve({
        success: true,
        listKey: keystoneListKey,
        itemId: keystoneItemId
      });
    }));
  }

  getContext(req) {
    return {
      startAuthedSession: ({
        item,
        list
      }) => this.startAuthedSession(req, {
        item,
        list
      }),
      endAuthedSession: () => this.endAuthedSession(req)
    };
  }

}

exports.SessionManager = SessionManager;
