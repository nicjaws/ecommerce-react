import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import _extends from '@babel/runtime/helpers/esm/extends';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import { jsx } from '@emotion/core';
import { Component, Suspense } from 'react';
import { useImage } from 'react-image';
import PropTypes from 'prop-types';
import { FieldContainer, FieldLabel, FieldDescription, FieldInput } from '@arch-ui/fields';
import { AlertIcon, FileMediaIcon } from '@primer/octicons-react';
import { HiddenInput } from '@arch-ui/input';
import { LoadingIndicator } from '@arch-ui/loading';
import { Lozenge } from '@arch-ui/lozenge';
import { LoadingButton, Button } from '@arch-ui/button';
import { FlexGroup } from '@arch-ui/layout';
import { gridSize, colors, borderRadius } from '@arch-ui/theme';
import isEqual from 'lodash.isequal';

function uploadButtonLabelFn({
  status
}) {
  return status === 'empty' ? 'Upload File' : 'Change File';
}

function cancelButtonLabelFn({
  status
}) {
  switch (status) {
    case 'stored':
      return 'Remove File';

    case 'removed':
      return 'Undo Remove';

    case 'updated':
    default:
      return 'Cancel';
  }
}

function statusMessageFn({
  status
}) {
  switch (status) {
    case 'removed':
      return 'save to remove';

    case 'updated':
      return 'save to upload';
  }
}

function errorMessageFn({
  type
}) {
  switch (type) {
    case 'save':
      return 'Something went wrong, please reload and try again.';

    case 'preview':
      return 'Something went wrong, please try again.';
  }
}

class FileField extends Component {
  static getDerivedStateFromProps(props, state) {
    const {
      savedValue,
      value
    } = props;
    const {
      changeStatus
    } = state;

    switch (changeStatus) {
      case 'removed':
        //file was removed and change was saved.
        if (savedValue === null && value === null) {
          return {
            originalFile: savedValue,
            changeStatus: 'empty'
          };
        }

        break;

      case 'updated':
        //file was updated and change was saved
        if (isEqual(savedValue, value)) {
          return {
            originalFile: savedValue,
            changeStatus: 'stored'
          };
        }

        break;
    }

    return null;
  }

  constructor(props) {
    super(props);

    _defineProperty(this, "onCancel", () => {
      // revert to the original file if available
      const {
        originalFile
      } = this.state;
      this.props.onChange(originalFile);
      if (this.inputRef) this.inputRef.value = '';
      this.setState({
        changeStatus: originalFile ? 'stored' : 'empty',
        dataURI: null,
        errorMessage: null
      });
    });

    _defineProperty(this, "onRemove", () => {
      this.setState({
        changeStatus: 'removed',
        errorMessage: null
      });
      this.props.onChange(null);
    });

    _defineProperty(this, "onChange", ({
      target: {
        validity,
        files: [file]
      }
    }) => {
      if (!file) return; // bail if the user cancels from the file browser

      const {
        errorMessage,
        onChange
      } = this.props;
      const newState = {
        changeStatus: 'updated'
      }; // basic validity check

      if (!validity.valid) {
        this.setState({
          errorMessage: errorMessage({
            type: 'save'
          })
        });
        return;
      } // resolve data URI for images


      if (file.type.includes('image')) {
        this.getDataURI(file);
        newState.oldImagePath = this.getImagePath(); // used during FileReader processing
      } else if (this.state.dataURI) {
        this.setState({
          dataURI: null,
          errorMessage: null
        });
      }

      onChange(file);
      this.setState(newState);
    });

    _defineProperty(this, "openFileBrowser", () => {
      if (this.inputRef) this.inputRef.click();
    });

    _defineProperty(this, "getFile", () => {
      const {
        value
      } = this.props;
      const {
        changeStatus,
        originalFile
      } = this.state;
      const isRemoved = changeStatus === 'removed';
      const file = isRemoved ? originalFile : value;
      const type = file && file['__typename'] ? 'server' : 'client';
      return {
        file,
        type
      };
    });

    _defineProperty(this, "getDataURI", file => {
      const {
        errorMessage
      } = this.props;
      const reader = new FileReader();
      reader.readAsDataURL(file);

      reader.onloadstart = () => {
        this.setState({
          isLoading: true
        });
      };

      reader.onerror = err => {
        console.error('Error with Cloudinary preview', err);
        this.setState({
          errorMessage: errorMessage({
            type: 'preview'
          })
        });
      };

      reader.onloadend = upload => {
        this.setState({
          isLoading: false,
          dataURI: upload.target.result
        });
      };
    });

    _defineProperty(this, "getImagePath", () => {
      const {
        dataURI
      } = this.state;
      const {
        file
      } = this.getFile(); // avoid jank during FileReader processing keeping the old image in place

      return file && file.mimetype && file.mimetype.includes('image') ? file.publicUrl : dataURI;
    });

    _defineProperty(this, "getInputRef", ref => {
      this.inputRef = ref;
    });

    _defineProperty(this, "renderUploadButton", () => {
      const {
        uploadButtonLabel,
        isDisabled
      } = this.props;
      const {
        changeStatus,
        isLoading
      } = this.state;
      return jsx(LoadingButton, {
        onClick: this.openFileBrowser,
        isLoading: isLoading,
        variant: "ghost",
        isDisabled: isDisabled
      }, uploadButtonLabel({
        status: changeStatus
      }));
    });

    _defineProperty(this, "renderCancelButton", () => {
      const {
        cancelButtonLabel,
        isDisabled
      } = this.props;
      const {
        changeStatus
      } = this.state; // possible states; no case for 'empty' as cancel is not rendered

      let appearance = 'warning';
      let onClick = this.onRemove;

      switch (changeStatus) {
        case 'removed':
          appearance = 'primary';
          onClick = this.onCancel;
          break;

        case 'updated':
          onClick = this.onCancel;
          break;
      }

      return jsx(Button, {
        onClick: onClick,
        variant: "subtle",
        appearance: appearance,
        isDisabled: isDisabled
      }, cancelButtonLabel({
        status: changeStatus
      }));
    });

    const {
      value: _value
    } = props;

    const _changeStatus = _value ? 'stored' : 'empty';

    this.state = {
      originalFile: _value,
      changeStatus: _changeStatus,
      dataURI: null,
      errorMessage: null,
      isLoading: false,
      oldImagePath: null
    };
  } // ==============================
  // Change Handlers
  // ==============================


  render() {
    const {
      autoFocus,
      field,
      statusMessage,
      errors,
      isDisabled
    } = this.props;
    const {
      changeStatus,
      errorMessage
    } = this.state;
    const {
      file
    } = this.getFile();
    const imagePath = this.getImagePath();
    const showStatusMessage = ['removed', 'updated'].includes(changeStatus);
    const htmlID = `ks-input-${field.path}`;
    return jsx(FieldContainer, null, jsx(FieldLabel, {
      htmlFor: htmlID,
      field: field,
      errors: errors
    }), jsx(FieldDescription, {
      text: field.adminDoc
    }), jsx(FieldInput, null, file ? jsx(Wrapper, null, imagePath && jsx(ImageContainer, {
      src: imagePath,
      alt: field.path
    }), jsx(Content, null, jsx(FlexGroup, {
      style: {
        marginBottom: gridSize
      }
    }, this.renderUploadButton(), this.renderCancelButton()), errorMessage ? jsx(ErrorInfo, null, errorMessage) : jsx(FlexGroup, {
      isInline: true,
      growIndexes: [0]
    }, jsx(MetaInfo, {
      href: file.publicUrl
    }, file.filename || file.name), showStatusMessage ? jsx(ChangeInfo, {
      status: changeStatus
    }, statusMessage({
      status: changeStatus
    })) : null))) : this.renderUploadButton(), jsx(HiddenInput, {
      autoComplete: "off",
      autoFocus: autoFocus,
      id: htmlID,
      ref: this.getInputRef,
      name: field.path,
      onChange: this.onChange,
      type: "file",
      disabled: isDisabled
    })));
  }

} // ==============================
// Styled Components
// ==============================

_defineProperty(FileField, "propTypes", {
  cancelButtonLabel: PropTypes.func.isRequired,
  disabled: PropTypes.bool,
  errorMessage: PropTypes.func.isRequired,
  field: PropTypes.object,
  onChange: PropTypes.func.isRequired,
  statusMessage: PropTypes.func.isRequired,
  uploadButtonLabel: PropTypes.func.isRequired
});

_defineProperty(FileField, "defaultProps", {
  cancelButtonLabel: cancelButtonLabelFn,
  errorMessage: errorMessageFn,
  statusMessage: statusMessageFn,
  uploadButtonLabel: uploadButtonLabelFn
});

const Wrapper = props => jsx("div", _extends({
  css: {
    alignItems: 'flex-start',
    display: 'flex'
  }
}, props));

const Content = props => jsx("div", _extends({
  css: {
    flex: 1,
    minWidth: 0
  }
}, props));

const MetaInfo = props => jsx(Lozenge, _extends({
  crop: "right"
}, props));

const ErrorInfo = (_ref) => {
  let {
    children
  } = _ref,
      props = _objectWithoutProperties(_ref, ["children"]);

  return jsx(Lozenge, _extends({
    style: {
      backgroundColor: colors.R.L80,
      borderColor: 'transparent',
      color: colors.R.D20,
      display: 'inline-flex'
    }
  }, props), jsx(AlertIcon, {
    css: {
      marginRight: gridSize
    }
  }), children);
};

const appearanceMap = {
  default: 'primary',
  removed: 'danger',
  updated: 'create'
};

const ChangeInfo = (_ref2) => {
  let {
    status = 'default'
  } = _ref2,
      props = _objectWithoutProperties(_ref2, ["status"]);

  const appearance = appearanceMap[status];
  return jsx(Lozenge, _extends({
    appearance: appearance
  }, props));
};

const Image = ({
  src: imgSrc,
  alt
}) => {
  const {
    src
  } = useImage({
    srcList: imgSrc
  });
  return jsx("img", {
    css: {
      display: 'block',
      height: 'auto',
      maxWidth: '100%'
    },
    src: src,
    alt: alt
  });
};

const ImageContainer = props => {
  return jsx("div", {
    css: {
      backgroundColor: 'white',
      borderRadius,
      border: `1px solid ${colors.N20}`,
      flexShrink: 0,
      marginRight: gridSize,
      padding: '4px',
      position: 'relative',
      textAlign: 'center',
      width: 130 // 120px image + chrome

    }
  }, jsx(ImageErrorBoundary, null, jsx(Suspense, {
    fallback: jsx(LoadingIndicator, null)
  }, jsx(Image, props))));
};

class ImageErrorBoundary extends Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      hasError: false
    });
  }

  static getDerivedStateFromError() {
    return {
      hasError: true
    };
  }

  render() {
    if (this.state.hasError) {
      return jsx("div", {
        css: {
          padding: '4px 0',
          color: colors.N40
        }
      }, jsx("div", null, jsx(FileMediaIcon, null)), jsx("span", {
        css: {
          fontSize: '0.9em'
        }
      }, "Could not load image"));
    }

    return this.props.children;
  }

}

export default FileField;
