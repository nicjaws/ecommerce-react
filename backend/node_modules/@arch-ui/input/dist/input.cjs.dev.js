'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var _extends = require('@babel/runtime/helpers/extends');
var core = require('@emotion/core');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var common = require('@arch-ui/common');
var theme = require('@arch-ui/theme');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefault(React);
var _extends__default = /*#__PURE__*/_interopDefault(_extends);
var _objectWithoutProperties__default = /*#__PURE__*/_interopDefault(_objectWithoutProperties);
var _defineProperty__default = /*#__PURE__*/_interopDefault(_defineProperty);

// ------------------------------

const HiddenInput = /*#__PURE__*/React.forwardRef((props, ref) => core.jsx("input", _extends__default['default']({
  ref: ref,
  css: {
    display: 'none'
  }
}, props)));

// ==============================

/*
 *  Why?
 *  ------------------------------
 *  For a while now browsers have been ignoring the `autocomplete="off"`
 *  property on form and input elements:
 *  - https://bugs.chromium.org/p/chromium/issues/detail?id=468153#c164
 *
 *  How?
 *  ------------------------------
 *  Browsers will autocomplete inputs in the order they're encountered; this
 *  component will capture the browser's attempt to autocomplete into these
 *  two hidden inputs and leave your legitimate fields unpolluted.
 *
 *  NOTE
 *  ------------------------------
 *  This component *must* be rendered before your legitimate fields.
 */

const AutocompleteCaptor = /*#__PURE__*/React.memo(function AutocompleteCaptor() {
  return /*#__PURE__*/React__default['default'].createElement(React.Fragment, null, /*#__PURE__*/React__default['default'].createElement(HiddenInput, {
    autoComplete: "username",
    type: "text",
    tabIndex: -1
  }), /*#__PURE__*/React__default['default'].createElement(HiddenInput, {
    autoComplete: "email",
    type: "text",
    tabIndex: -1
  }), /*#__PURE__*/React__default['default'].createElement(HiddenInput, {
    autoComplete: "current-password",
    type: "password",
    tabIndex: -1
  }), /*#__PURE__*/React__default['default'].createElement(HiddenInput, {
    autoComplete: "new-password",
    type: "password",
    tabIndex: -1
  }));
}, () => true);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
// Basic Input
// ------------------------------

const inputStyles = (props = {}) => _objectSpread(_objectSpread({}, common.uniformHeight), {}, {
  backgroundColor: props.disabled ? theme.colors.N10 : 'white',
  borderColor: theme.colors.N20,
  color: 'inherit',
  width: '100%',
  ':hover': {
    borderColor: theme.colors.N30,
    outline: 0
  },
  ':focus': {
    borderColor: theme.colors.primary,
    outline: 0
  },
  ':invalid': {
    borderColor: theme.colors.danger,
    outline: 0
  },
  '&[disabled]': {
    borderColor: theme.colors.N15,
    backgroundColor: theme.colors.N05
  }
}, props.isMultiline ? {
  lineHeight: 'inherit',
  minHeight: 100,
  resize: 'vertical',
  whiteSpace: 'wrap'
} : undefined);
const Input = /*#__PURE__*/React.forwardRef((props, ref) => {
  const {
    isMultiline
  } = props,
        inputProps = _objectWithoutProperties__default['default'](props, ["isMultiline"]);

  const Component = isMultiline ? 'textarea' : 'input';
  return core.jsx(Component, _extends__default['default']({
    ref: ref,
    css: inputStyles(props)
  }, inputProps));
});

exports.AutocompleteCaptor = AutocompleteCaptor;
exports.HiddenInput = HiddenInput;
exports.Input = Input;
exports.inputStyles = inputStyles;
