import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import React, { forwardRef, useState, useRef, useImperativeHandle, useEffect, useDebugValue, Fragment, memo } from 'react';
import { TransitionGroup, Transition } from 'react-transition-group';
import { jsx } from '@emotion/core';
import { colors } from '@arch-ui/theme';
import { alpha } from '@arch-ui/color-utils';
import ScrollLock from 'react-scrolllock';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const transitionDurationMs = 220;
const transitionDuration = `${transitionDurationMs}ms`;
const transitionTimingFunction = 'cubic-bezier(0.2, 0, 0, 1)';
const TransitionProvider = (_ref) => {
  let {
    children,
    isOpen
  } = _ref,
      props = _objectWithoutProperties(_ref, ["children", "isOpen"]);

  return /*#__PURE__*/React.createElement(TransitionGroup, {
    component: null
  }, isOpen ? /*#__PURE__*/React.createElement(Transition, _extends({
    appear: true,
    mountOnEnter: true,
    unmountOnExit: true,
    timeout: transitionDurationMs
  }, props), state => children(state)) : null);
};
const withTransitionState = Comp => (_ref2) => {
  let {
    isOpen
  } = _ref2,
      props = _objectWithoutProperties(_ref2, ["isOpen"]);

  return /*#__PURE__*/React.createElement(TransitionProvider, {
    isOpen: Boolean(isOpen)
  }, state => /*#__PURE__*/React.createElement(Comp, _extends({
    transitionState: state
  }, props)));
}; // ==============================
// Transitions
// ==============================

function makeTransitionBase(transitionProperty) {
  return {
    transitionProperty,
    transitionDuration,
    transitionTimingFunction
  };
}

const fade = transitionState => _objectSpread(_objectSpread({}, makeTransitionBase('opacity')), {}, {
  opacity: {
    entering: 1,
    entered: 1,
    exiting: 0,
    exited: 0
  }[transitionState]
}); // Slide Up
// ------------------------------

const slideUp = transitionState => {
  const out = {
    opacity: 0,
    transform: 'scale(0.95) translate3d(0,20px,0)'
  };
  return _objectSpread(_objectSpread({}, makeTransitionBase('opacity, transform')), {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    },
    exiting: out,
    exited: out
  }[transitionState]);
};
const slideDown = (transitionState, {
  from = '-8px'
} = {}) => {
  const out = {
    opacity: 0,
    transform: `translate3d(0,${from},0)`
  };
  return _objectSpread(_objectSpread({}, makeTransitionBase('opacity, transform')), {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    },
    exiting: out,
    exited: out
  }[transitionState]);
};
const fromMap = {
  left: '-100%',
  right: '100%'
}; // NOTE: should be able to use $Keys<typeof fromMap>

const slideInHorizontal = (transitionState, {
  slideInFrom
}) => {
  const initial = fromMap[slideInFrom];
  return _objectSpread(_objectSpread({}, makeTransitionBase('transform')), {
    entering: {
      transform: 'translate3d(0,0,0)'
    },
    entered: {
      transform: 'translate3d(0,0,0)'
    },
    exiting: {
      transform: `translate3d(${initial}, 0, 0)`
    },
    exited: {
      transform: `translate3d(${initial}, 0, 0)`
    }
  }[transitionState]);
};
const zoomInDown = transitionState => {
  return _objectSpread({
    transformOrigin: 'top',
    transitionProperty: 'opacity, transform',
    transitionDuration,
    transitionTimingFunction
  }, {
    entering: {
      opacity: 1,
      transform: 'translate3d(0, 0, 0)'
    },
    entered: {
      opacity: 1,
      transform: 'translate3d(0, 0, 0)'
    },
    exiting: {
      opacity: 0,
      transform: 'scale3d(0.33, 0.33, 0.33) translate3d(0, -100%, 0)'
    },
    exited: {
      opacity: 0,
      transform: 'scale3d(0.33, 0.33, 0.33) translate3d(0, -100%, 0)'
    }
  }[transitionState]);
};
const springDown = transitionState => {
  return _objectSpread({
    transformOrigin: 'top',
    transitionProperty: 'opacity, transform',
    transitionDuration,
    transitionTimingFunction: 'cubic-bezier(0.2, 0, 0.16, 1.6)'
  }, {
    entering: {
      opacity: 1,
      transform: 'translate3d(0, 0, 0)'
    },
    entered: {
      opacity: 1,
      transform: 'translate3d(0, 0, 0)'
    },
    exiting: {
      opacity: 0,
      transform: 'scale(0.93) translate3d(0, -12px, 0)'
    },
    exited: {
      opacity: 0,
      transform: 'scale(0.93) translate3d(0, -12px, 0)'
    }
  }[transitionState]);
};

const Blanket = (_ref) => {
  let {
    isTinted,
    isLight
  } = _ref,
      props = _objectWithoutProperties(_ref, ["isTinted", "isLight"]);

  let bg = 'transparent';

  if (isTinted) {
    bg = isLight ? 'rgba(255, 255, 255, 0.5)' : alpha(colors.N100, 0.2);
  }

  return jsx("div", _extends({
    css: {
      backgroundColor: bg,
      bottom: 0,
      left: 0,
      position: 'fixed',
      right: 0,
      top: 0,
      zIndex: 2
    }
  }, props));
};

const getDisplayName = C => {
  return `withModalHandlers(${C.displayName || C.name || 'Component'})`;
};

const Target = /*#__PURE__*/memo(({
  isOpen,
  mode,
  target,
  targetRef,
  open,
  toggle
}) => {
  const cloneProps = {
    isActive: isOpen,
    ref: targetRef
  };
  if (mode === 'click') cloneProps.onClick = toggle;
  if (mode === 'contextmenu') cloneProps.onContextMenu = open;
  return target(cloneProps);
});

const withModalHandlers = (WrappedComponent, {
  transition
}) => {
  return /*#__PURE__*/forwardRef((_ref, ref) => {
    let {
      defaultIsOpen = false,
      mode = 'click',
      onClose = () => {},
      onOpen = () => {},
      target
    } = _ref,
        props = _objectWithoutProperties(_ref, ["defaultIsOpen", "mode", "onClose", "onOpen", "target"]);

    const [isOpen, setIsOpen] = useState(defaultIsOpen); // TODO: remove. Wrapped components (currently only Dropdown) use these for calculating position,
    // but react-popper should be used instead

    const [clientX, setClientX] = useState(0);
    const [clientY, setClientY] = useState(0);
    const contentNode = useRef();
    const targetNode = useRef(); // Expose open() and close() for via ref

    useImperativeHandle(ref, () => ({
      open,
      close
    }));
    useEffect(() => {
      // If the dialog was closed, don't do anything. The cleanup function already removed the handlers.
      if (!isOpen) return;

      const handleMouseDown = event => {
        const {
          target
        } = event;

        if (!(target instanceof HTMLElement) && !(target instanceof SVGElement)) {
          return;
        }

        const clickNotIn = node => !node.current.contains(target); // NOTE: Why not use the <Blanket /> component to close?
        // We don't want to interrupt the user's flow. Taking this approach allows
        // user to click "through" to other elements and close the popout.


        if (isOpen && clickNotIn(contentNode) && clickNotIn(targetNode)) {
          close(event);
        }
      };

      const handleKeyDown = event => {
        const {
          key
        } = event;

        if (key === 'Escape') {
          close(event);
        }
      };

      document.addEventListener('mousedown', handleMouseDown);
      document.addEventListener('keydown', handleKeyDown, false);
      return () => {
        document.removeEventListener('mousedown', handleMouseDown);
        document.removeEventListener('keydown', handleKeyDown, false);
      };
    }, [isOpen]);
    useDebugValue(getDisplayName(WrappedComponent));

    const open = event => {
      if (event.defaultPrevented) return;
      if (mode === 'contextmenu') event.preventDefault();
      const {
        clientX,
        clientY
      } = event;
      setIsOpen(true);
      setClientX(clientX);
      setClientY(clientY);
    };

    const close = event => {
      if (event && event.defaultPrevented) return;
      setIsOpen(false);
      setClientX(0);
      setClientY(0);
    };

    const toggle = event => {
      if (isOpen) {
        close(event);
      } else {
        open(event);
      }
    };

    const getTarget = ref => {
      targetNode.current = ref;
    };

    const getContent = ref => {
      contentNode.current = ref;
    };

    return /*#__PURE__*/React.createElement(Fragment, null, /*#__PURE__*/React.createElement(Target, {
      targetRef: getTarget,
      target: target,
      mode: mode,
      isOpen: isOpen,
      toggle: toggle,
      open: open
    }), isOpen && /*#__PURE__*/React.createElement(ScrollLock, null), /*#__PURE__*/React.createElement(TransitionProvider, {
      isOpen: isOpen,
      onEntered: onOpen,
      onExited: onClose
    }, transitionState => /*#__PURE__*/React.createElement(WrappedComponent, _extends({
      close: close,
      open: open,
      getModalRef: getContent,
      targetNode: targetNode.current,
      contentNode: contentNode.current,
      isOpen: isOpen,
      mouseCoords: {
        clientX,
        clientY
      },
      style: transition(transitionState)
    }, props))));
  });
};

function generateUEID() {
  let first = Math.random() * 46656 | 0;
  let second = Math.random() * 46656 | 0;
  first = ('000' + first.toString(36)).slice(-3);
  second = ('000' + second.toString(36)).slice(-3);
  return first + second;
}

export { Blanket, TransitionProvider, fade, generateUEID, slideDown, slideInHorizontal, slideUp, springDown, withModalHandlers, withTransitionState, zoomInDown };
