import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import { useState, useEffect, useCallback, useMemo, Fragment, forwardRef } from 'react';
import { usePopper } from 'react-popper';
import { jsx, useTheme, Portal } from '@keystone-ui/core';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const useControlledPopover = ({
  isOpen,
  onClose
}, popperOptions = {}, popoverOptions = {
  handleClose: 'both'
}) => {
  const [anchorElement, setAnchorElement] = useState(null);
  const [popoverElement, setPopoverElement] = useState();
  const [arrowElement, setArrowElement] = useState();
  const {
    styles,
    attributes,
    update
  } = usePopper(anchorElement, popoverElement, _objectSpread2(_objectSpread2({}, popperOptions), {}, {
    modifiers: [...(popperOptions.modifiers || []), {
      name: 'arrow',
      options: {
        element: arrowElement
      }
    }, {
      name: 'eventListeners',
      options: {
        scroll: isOpen,
        resize: isOpen
      }
    }]
  })); // update popper when it opens to get the latest placement
  // useful for prerendered popovers in modals etc.

  useEffect(() => {
    if (update && isOpen) {
      update();
    }
  }, [isOpen, update]); // close on click outside

  useClickOutside({
    handler: () => onClose(),
    elements: [anchorElement, popoverElement],
    listenWhen: ['both', 'mouse'].includes(popoverOptions.handleClose) && isOpen
  }); // close on esc press

  useKeyPress({
    targetKey: 'Escape',
    downHandler: useCallback(event => {
      event.preventDefault(); // Avoid potential close of modal

      onClose();
    }, [onClose]),
    listenWhen: ['both', 'keyboard'].includes(popoverOptions.handleClose) && isOpen
  });
  return {
    trigger: useMemo(() => ({
      ref: setAnchorElement,
      props: {
        'aria-haspopup': true,
        'aria-expanded': isOpen
      }
    }), [isOpen]),
    dialog: useMemo(() => ({
      ref: setPopoverElement,
      props: _objectSpread2({
        style: styles.popper
      }, attributes.popper)
    }), [styles.popper, attributes.popper]),
    arrow: useMemo(() => ({
      ref: setArrowElement,
      props: {
        style: styles.arrow
      }
    }), [styles.arrow])
  };
};
const usePopover = (popperOptions = {}, popoverOptions = {
  handleClose: 'both'
}) => {
  const [isOpen, setOpen] = useState(false);
  return _objectSpread2({
    isOpen,
    setOpen
  }, useControlledPopover({
    isOpen,
    onClose: useCallback(() => setOpen(false), [])
  }, popperOptions, popoverOptions));
}; // Component
// ------------------------------

const Popover = (_ref) => {
  let {
    placement = 'bottom',
    triggerRenderer
  } = _ref,
      props = _objectWithoutProperties(_ref, ["placement", "triggerRenderer"]);

  const {
    isOpen,
    setOpen,
    trigger,
    dialog,
    arrow
  } = usePopover({
    placement,
    modifiers: [{
      name: 'offset',
      options: {
        offset: [0, 8]
      }
    }]
  });
  return jsx(Fragment, null, triggerRenderer({
    isOpen,
    triggerProps: _objectSpread2(_objectSpread2({
      ref: trigger.ref
    }, trigger.props), {}, {
      onClick: () => setOpen(true)
    })
  }), jsx(PopoverDialog, _extends({
    isVisible: isOpen,
    arrow: arrow,
    ref: dialog.ref
  }, dialog.props, props)));
}; // Dialog
// ------------------------------

const PopoverDialog = /*#__PURE__*/forwardRef((_ref2, consumerRef) => {
  let {
    isVisible,
    children,
    arrow
  } = _ref2,
      props = _objectWithoutProperties(_ref2, ["isVisible", "children", "arrow"]);

  const {
    elevation,
    radii,
    shadow,
    colors
  } = useTheme();
  return jsx(Portal, null, jsx("div", _extends({
    ref: consumerRef,
    css: _objectSpread2({
      background: colors.background,
      borderRadius: radii.medium,
      boxShadow: shadow.s300,
      opacity: isVisible ? 1 : 0,
      pointerEvents: isVisible ? undefined : 'none',
      zIndex: elevation.e500
    }, useArrowStyles())
  }, props), jsx("div", _extends({
    "data-popper-arrow": true,
    ref: arrow.ref,
    className: "tooltipArrow"
  }, arrow.props)), children));
}); // TODO: maybe we should add an invisible blanket and have a regular react event listener on that instead of this?
// NOTE: mouse event handler defined here rather than imported from react becase
// the event listener will return a native event, not a synthetic event

const useClickOutside = ({
  handler,
  elements,
  listenWhen
}) => {
  useEffect(() => {
    if (listenWhen) {
      let handleMouseDown = event => {
        // bail on mouse down "inside" any of the provided elements
        if (elements.some(el => el && el.contains(event.target))) {
          return;
        }

        handler(event);
      };

      document.addEventListener('mousedown', handleMouseDown);
      return () => {
        document.removeEventListener('mousedown', handleMouseDown);
      };
    }
  }, [handler, elements, listenWhen]);
};

const useKeyPress = ({
  targetKey,
  targetElement,
  downHandler,
  upHandler,
  listenWhen
}) => {
  // Keep track of whether the target key is pressed
  const [keyPressed, setKeyPressed] = useState(false); // add event listeners

  useEffect(() => {
    let target = targetElement || document.body;

    let onDown = event => {
      if (event.key === targetKey) {
        setKeyPressed(true);

        if (typeof downHandler === 'function') {
          downHandler(event);
        }
      }
    };

    let onUp = event => {
      if (event.key === targetKey) {
        setKeyPressed(false);

        if (typeof upHandler === 'function') {
          upHandler(event);
        }
      }
    };

    if (listenWhen) {
      target.addEventListener('keydown', onDown);
      target.addEventListener('keyup', onUp); // Remove event listeners on cleanup

      return () => {
        target.removeEventListener('keydown', onDown);
        target.removeEventListener('keyup', onUp);
      };
    }
  }, [listenWhen, targetKey, downHandler, upHandler, targetElement]);
  return keyPressed;
};

const useArrowStyles = () => {
  const theme = useTheme();
  const size = 16;
  return {
    '& [data-popper-arrow]': {
      position: 'absolute',
      overflow: 'hidden',
      pointerEvents: 'none',
      height: size * 2,
      width: size * 2,
      '&::after': {
        content: '""',
        position: 'absolute',
        background: theme.colors.background,
        width: size,
        height: size,
        transform: 'translateX(-50%) translateY(-50%) rotate(45deg)',
        boxShadow: theme.shadow.s200
      }
    },
    "&[data-popper-placement^='left'] > [data-popper-arrow]": {
      left: '100%',
      '&::after': {
        top: '50%',
        left: '0'
      }
    },
    "&[data-popper-placement^='right'] > [data-popper-arrow]": {
      right: '100%',
      '&::after': {
        top: '50%',
        left: '100%'
      }
    },
    "&[data-popper-placement^='top'] > [data-popper-arrow]": {
      top: '100%',
      '&::after': {
        top: 0,
        bottom: '-50%',
        left: '50%'
      }
    },
    "&[data-popper-placement^='bottom'] > [data-popper-arrow]": {
      bottom: '100%',
      right: 'unset',
      '&::after': {
        bottom: '-50%',
        left: '50%'
      }
    }
  };
};

export { Popover, PopoverDialog, useControlledPopover, usePopover };
