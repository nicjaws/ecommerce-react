import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import { useMemo } from 'react';
import { useTheme, jsx, useId, makeId, Stack } from '@keystone-ui/core';
import { AlertOctagonIcon } from '@keystone-ui/icons/icons/AlertOctagonIcon';
import { AlertCircleIcon } from '@keystone-ui/icons/icons/AlertCircleIcon';
import { AlertTriangleIcon } from '@keystone-ui/icons/icons/AlertTriangleIcon';
import { CheckCircleIcon } from '@keystone-ui/icons/icons/CheckCircleIcon';
import { InfoIcon } from '@keystone-ui/icons/icons/InfoIcon';
import { HelpCircleIcon } from '@keystone-ui/icons/icons/HelpCircleIcon';
import { ButtonProvider, Button } from '@keystone-ui/button';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const noticeToneValues = ['active', 'passive', 'positive', 'warning', 'negative', 'help'];
function useNoticeTokens({
  tone: toneKey
}) {
  const {
    colors,
    radii,
    tones,
    typography,
    spacing
  } = useTheme();
  const tone = tones[toneKey];
  const tokens = {
    background: tone.tint[0],
    borderColor: tone.border[0],
    borderRadius: radii.medium,
    borderWidth: 1,
    fontSize: typography.fontSize.small,
    fontWeight: typography.fontWeight.medium,
    foreground: colors.foregroundDim,
    gap: spacing.medium,
    iconColor: tone.foreground[0],
    paddingX: spacing.large,
    paddingY: spacing.large,
    title: {
      foreground: colors.foreground,
      fontSize: typography.fontSize.medium,
      fontWeight: typography.fontWeight.medium
    }
  };
  return tokens;
}
function useNoticeStyles({
  tokens
}) {
  const actions = {
    marginTop: tokens.gap
  };
  const box = {
    backgroundColor: tokens.background,
    borderColor: tokens.borderColor || 'transparent',
    borderRadius: tokens.borderRadius,
    borderWidth: tokens.borderWidth,
    color: tokens.foreground,
    fontSize: tokens.fontSize,
    fontWeight: tokens.fontWeight,
    paddingLeft: tokens.paddingX,
    paddingRight: tokens.paddingX,
    paddingTop: tokens.paddingY,
    paddingBottom: tokens.paddingY
  };
  const title = {
    color: tokens.title.foreground,
    fontSize: tokens.title.fontSize,
    fontWeight: tokens.title.fontWeight,
    marginBottom: tokens.gap / 2
  };
  const symbol = {
    color: tokens.iconColor,
    marginRight: tokens.gap
  };
  return {
    actions,
    box,
    title,
    symbol
  };
}

function useButtonTokens({
  tone: toneKey,
  size: sizeKey,
  weight: weightKey
}) {
  const {
    animation,
    colors,
    tones,
    typography,
    controlSizes,
    opacity
  } = useTheme();
  const tone = tones[toneKey];
  const size = controlSizes[sizeKey];
  const weights = {
    bold: {
      background: 'white',
      borderColor: tone.border[0],
      foreground: colors.foreground,
      focus: {
        shadow: `0 0 0 2px ${tone.focusRing}`
      },
      hover: {
        foreground: tone.foreground[1],
        background: tone.tint[1]
      },
      pressed: {
        foreground: tone.foreground[2],
        background: tone.tint[2]
      }
    },
    light: {
      background: tone.tint[0],
      foreground: colors.foreground,
      focus: {
        shadow: `0 0 0 2px ${tone.focusRing}`
      },
      hover: {
        foreground: tone.foreground[1],
        background: tone.tint[1]
      },
      pressed: {
        foreground: tone.foreground[2],
        background: tone.tint[2]
      }
    },
    none: {
      foreground: colors.foreground,
      focus: {
        shadow: `0 0 0 2px ${tone.focusRing}`
      },
      hover: {
        foreground: tone.foreground[0],
        background: tone.tint[0]
      },
      pressed: {
        foreground: tone.foreground[1],
        background: tone.tint[1]
      }
    },
    link: {
      foreground: colors.foreground,
      focus: {
        textDecoration: 'underline'
      },
      hover: {
        foreground: tone.foreground[0],
        textDecoration: 'underline'
      },
      pressed: {
        foreground: tone.foreground[1],
        textDecoration: 'underline'
      }
    }
  };
  const weight = weights[weightKey];

  const tokens = _objectSpread2({
    borderRadius: size.borderRadius,
    borderWidth: size.borderWidth,
    disabledOpacity: opacity.disabled,
    fontSize: size.fontSize,
    fontWeight: typography.fontWeight.semibold,
    height: size.height,
    paddingX: size.paddingX,
    transition: `
      background-color ${animation.duration100},
      box-shadow ${animation.duration100},
      border-color ${animation.duration100},
      opacity ${animation.duration100},
    `
  }, weight);

  return tokens;
}

const symbols = {
  active: jsx(InfoIcon, null),
  passive: jsx(AlertCircleIcon, null),
  positive: jsx(CheckCircleIcon, null),
  warning: jsx(AlertTriangleIcon, null),
  negative: jsx(AlertOctagonIcon, null),
  help: jsx(HelpCircleIcon, null)
};
const Notice = (_ref) => {
  let {
    actions,
    children,
    tone = 'passive',
    title
  } = _ref,
      otherProps = _objectWithoutProperties(_ref, ["actions", "children", "tone", "title"]);

  const id = useId();
  const titleId = makeId('notice-title', id);
  const contentId = makeId('notice-content', id);
  const tokens = useNoticeTokens({
    tone
  });
  const styles = useNoticeStyles({
    tokens
  });
  const buttonContext = useMemo(() => ({
    hooks: {
      useButtonTokens
    },
    defaults: {
      tone,
      size: 'small'
    }
  }), [tone]);
  return jsx(ButtonProvider, buttonContext, jsx("div", _extends({
    css: _objectSpread2({
      display: 'flex',
      flex: 1,
      flexDirection: 'row',
      outline: 0
    }, styles.box),
    tabIndex: 0,
    role: "alert",
    "aria-live": "polite",
    "aria-labelledby": titleId,
    "aria-describedby": contentId
  }, otherProps), jsx("div", {
    css: styles.symbol
  }, symbols[tone]), jsx("div", {
    css: {
      flex: 1
    }
  }, title && jsx("div", {
    id: titleId,
    css: _objectSpread2({
      marginTop: 1
    }, styles.title)
  }, title), jsx("div", {
    id: contentId,
    css: {
      marginTop: 2
    }
  }, children), actions && jsx(Stack, {
    across: true,
    gap: "small",
    css: styles.actions
  }, actions.primary && jsx(Button, {
    weight: "bold"
  }, actions.primary.label), actions.secondary && jsx(Button, {
    weight: "light"
  }, actions.secondary.label)))));
};

export { Notice, noticeToneValues, useNoticeStyles, useNoticeTokens };
