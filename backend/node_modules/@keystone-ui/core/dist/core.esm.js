import { jsx, css, Global } from '@emotion/react';
export { ClassNames, Global, css, jsx, keyframes } from '@emotion/react';
import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import React, { forwardRef, useState, useEffect, useLayoutEffect, createContext, useContext, Fragment, Children, isValidElement, useRef } from 'react';
import { createPortal } from 'react-dom';
import facepaint from 'facepaint';

/*
  @johannes' one weird trick for fixing TypeScript autocomplete
*/

function identityType() {
  function inner(u) {
    return u;
  }

  return inner;
}
/*
  Logs a warning to the console when the condition is true, only in dev
*/

const devWarning = (condition, message) => {
  if (process.env.NODE_ENV !== 'production') {
    if (condition) {
      console.error(message);
    }
  }
};
/*
  forwardRefWithAs lets us forward refs while keeping the correct component type,
  which can be specified by the `as` prop.
*/

const forwardRefWithAs = render => {
  // @ts-ignore
  return /*#__PURE__*/forwardRef(render);
};
/*
  A helper for making valid IDs from a set of inputs
*/

function makeId(...args) {
  return args.filter(val => val != null).join('--');
}
/*
  A helper for handling string OR array values e.g.

  <Component size="small" />
  VS
  <Component size={['small', 'large']} />
*/

const mapResponsiveProp = (value, valueMap) => {
  if (Array.isArray(value)) {
    return value.map(k => k == null ? null : valueMap[k]);
  } // @ts-ignore


  return valueMap[value];
};
/**
 * Utils below are ported with thanks from @reach-ui
 * Copyright (c) 2018-present, React Training LLC
 */
// Autogenerate IDs to facilitate WAI-ARIA and server rendering. For reasoning, see
// https://github.com/reach/reach-ui/blob/develop/packages/auto-id/src/index.tsx

let serverHandoffComplete = false;
let id = 0;

const genId = () => ++id;

const useId = idFromProps => {
  const initialId = idFromProps || (serverHandoffComplete ? genId() : null);
  const [id, setId] = useState(initialId);
  useSafeLayoutEffect(() => {
    if (id === null) {
      setId(genId());
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, []);
  useEffect(() => {
    if (serverHandoffComplete === false) {
      serverHandoffComplete = true;
    }
  }, []);
  return id != null ? String(id) : undefined;
}; // Works around useLayoutEffect throwing a warning when used in SSR

const useSafeLayoutEffect = typeof window === 'undefined' ? () => {} : useLayoutEffect;
const Portal = ({
  children
}) => {
  if (typeof document === 'undefined') {
    return null;
  }

  return /*#__PURE__*/createPortal(children, document.body);
};

// ------------------------------
// See: https://a11yproject.com/posts/how-to-hide-content/

const VisuallyHidden = forwardRefWithAs((_ref, ref) => {
  let {
    as: Tag = 'span'
  } = _ref,
      props = _objectWithoutProperties(_ref, ["as"]);

  return /*#__PURE__*/React.createElement(Tag, _extends({
    ref: ref,
    style: visuallyHiddenStyles
  }, props));
});
const visuallyHiddenStyles = {
  border: 0,
  clip: 'rect(0, 0, 0, 0)',
  height: 1,
  overflow: 'hidden',
  padding: 0,
  position: 'absolute',
  whiteSpace: 'nowrap',
  width: 1
};

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

/*
  Credit to TailwindCSS for this color palette, while we come up with our own
  https://github.com/tailwindlabs/tailwindcss
*/
const palette = {
  // rose50: '#fff1f2',
  // rose100: '#ffe4e6',
  // rose200: '#fecdd3',
  // rose300: '#fda4af',
  // rose400: '#fb7185',
  // rose500: '#f43f5e',
  // rose600: '#e11d48',
  // rose700: '#be123c',
  // rose800: '#9f1239',
  // rose900: '#881337',
  pink50: '#fdf2f8',
  pink100: '#fce7f3',
  pink200: '#fbcfe8',
  pink300: '#f9a8d4',
  pink400: '#f472b6',
  pink500: '#ec4899',
  pink600: '#db2777',
  pink700: '#be185d',
  pink800: '#9d174d',
  pink900: '#831843',
  // fuchsia50: '#fdf4ff',
  // fuchsia100: '#fae8ff',
  // fuchsia200: '#f5d0fe',
  // fuchsia300: '#f0abfc',
  // fuchsia400: '#e879f9',
  // fuchsia500: '#d946ef',
  // fuchsia600: '#c026d3',
  // fuchsia700: '#a21caf',
  // fuchsia800: '#86198f',
  // fuchsia900: '#701a75',
  // _purple50: '#faf5ff',
  // _purple100: '#f3e8ff',
  // _purple200: '#e9d5ff',
  // _purple300: '#d8b4fe',
  // _purple400: '#c084fc',
  // _purple500: '#a855f7',
  // _purple600: '#9333ea',
  // _purple700: '#7e22ce',
  // _purple800: '#6b21a8',
  // _purple900: '#581c87',
  purple50: '#f5f3ff',
  // was violet
  purple100: '#ede9fe',
  // was violet
  purple200: '#ddd6fe',
  // was violet
  purple300: '#c4b5fd',
  // was violet
  purple400: '#a78bfa',
  // was violet
  purple500: '#8b5cf6',
  // was violet
  purple600: '#7c3aed',
  // was violet
  purple700: '#6d28d9',
  // was violet
  purple800: '#5b21b6',
  // was violet
  purple900: '#4c1d95',
  // was violet
  // indigo50: '#eef2ff',
  // indigo100: '#e0e7ff',
  // indigo200: '#c7d2fe',
  // indigo300: '#a5b4fc',
  // indigo400: '#818cf8',
  // indigo500: '#6366f1',
  // indigo600: '#4f46e5',
  // indigo700: '#4338ca',
  // indigo800: '#3730a3',
  // indigo900: '#312e81',
  blue50: '#eff6ff',
  blue100: '#dbeafe',
  blue200: '#bfdbfe',
  blue300: '#93c5fd',
  blue400: '#60a5fa',
  blue500: '#3b82f6',
  blue600: '#2563eb',
  blue700: '#1d4ed8',
  blue800: '#1e40af',
  blue900: '#1e3a8a',
  // lightBlue50: '#f0f9ff',
  // lightBlue100: '#e0f2fe',
  // lightBlue200: '#bae6fd',
  // lightBlue300: '#7dd3fc',
  // lightBlue400: '#38bdf8',
  // lightBlue500: '#0ea5e9',
  // lightBlue600: '#0284c7',
  // lightBlue700: '#0369a1',
  // lightBlue800: '#075985',
  // lightBlue900: '#0c4a6e',
  cyan50: '#ecfeff',
  cyan100: '#cffafe',
  cyan200: '#a5f3fc',
  cyan300: '#67e8f9',
  cyan400: '#22d3ee',
  cyan500: '#06b6d4',
  cyan600: '#0891b2',
  cyan700: '#0e7490',
  cyan800: '#155e75',
  cyan900: '#164e63',
  teal50: '#f0fdfa',
  teal100: '#ccfbf1',
  teal200: '#99f6e4',
  teal300: '#5eead4',
  teal400: '#2dd4bf',
  teal500: '#14b8a6',
  teal600: '#0d9488',
  teal700: '#0f766e',
  teal800: '#115e59',
  teal900: '#134e4a',
  // emerald50: '#ecfdf5',
  // emerald100: '#d1fae5',
  // emerald200: '#a7f3d0',
  // emerald300: '#6ee7b7',
  // emerald400: '#34d399',
  // emerald500: '#10b981',
  // emerald600: '#059669',
  // emerald700: '#047857',
  // emerald800: '#065f46',
  // emerald900: '#064e3b',
  green50: '#f0fdf4',
  green100: '#dcfce7',
  green200: '#bbf7d0',
  green300: '#86efac',
  green400: '#4ade80',
  green500: '#22c55e',
  green600: '#16a34a',
  green700: '#15803d',
  green800: '#166534',
  green900: '#14532d',
  // lime50: '#f7fee7',
  // lime100: '#ecfccb',
  // lime200: '#d9f99d',
  // lime300: '#bef264',
  // lime400: '#a3e635',
  // lime500: '#84cc16',
  // lime600: '#65a30d',
  // lime700: '#4d7c0f',
  // lime800: '#3f6212',
  // lime900: '#365314',
  yellow50: '#fefce8',
  yellow100: '#fef9c3',
  yellow200: '#fef08a',
  yellow300: '#fde047',
  yellow400: '#facc15',
  yellow500: '#eab308',
  yellow600: '#ca8a04',
  yellow700: '#a16207',
  yellow800: '#854d0e',
  yellow900: '#713f12',
  // amber50: '#fffbeb',
  // amber100: '#fef3c7',
  // amber200: '#fde68a',
  // amber300: '#fcd34d',
  // amber400: '#fbbf24',
  // amber500: '#f59e0b',
  // amber600: '#d97706',
  // amber700: '#b45309',
  // amber800: '#92400e',
  // amber900: '#78350f',
  orange50: '#fff7ed',
  orange100: '#ffedd5',
  orange200: '#fed7aa',
  orange300: '#fdba74',
  orange400: '#fb923c',
  orange500: '#f97316',
  orange600: '#ea580c',
  orange700: '#c2410c',
  orange800: '#9a3412',
  orange900: '#7c2d12',
  red50: '#fef2f2',
  red100: '#fee2e2',
  red200: '#fecaca',
  red300: '#fca5a5',
  red400: '#f87171',
  red500: '#ef4444',
  red600: '#dc2626',
  red700: '#b91c1c',
  red800: '#991b1b',
  red900: '#7f1d1d' // warmGray50: '#fafaf9',
  // warmGray100: '#f5f5f4',
  // warmGray200: '#e7e5e4',
  // warmGray300: '#d6d3d1',
  // warmGray400: '#a8a29e',
  // warmGray500: '#78716c',
  // warmGray600: '#57534e',
  // warmGray700: '#44403c',
  // warmGray800: '#292524',
  // warmGray900: '#1c1917',
  // trueGray50: '#fafafa',
  // trueGray100: '#f5f5f5',
  // trueGray200: '#e5e5e5',
  // trueGray300: '#d4d4d4',
  // trueGray400: '#a3a3a3',
  // trueGray500: '#737373',
  // trueGray600: '#525252',
  // trueGray700: '#404040',
  // trueGray800: '#262626',
  // trueGray900: '#171717',
  // gray50: '#fafafa',
  // gray100: '#f4f4f5',
  // gray200: '#e4e4e7',
  // gray300: '#d4d4d8',
  // gray400: '#a1a1aa',
  // gray500: '#71717a',
  // gray600: '#52525b',
  // gray700: '#3f3f46',
  // gray800: '#27272a',
  // gray900: '#18181b',
  // coolGray50: '#f9fafb',
  // coolGray100: '#f3f4f6',
  // coolGray200: '#e5e7eb',
  // coolGray300: '#d1d5db',
  // coolGray400: '#9ca3af',
  // coolGray500: '#6b7280',
  // coolGray600: '#4b5563',
  // coolGray700: '#374151',
  // coolGray800: '#1f2937',
  // coolGray900: '#111827',
  // blueGray50: '#f8fafc',
  // blueGray100: '#f1f5f9',
  // blueGray200: '#e2e8f0',
  // blueGray300: '#cbd5e1',
  // blueGray400: '#94a3b8',
  // blueGray500: '#64748b',
  // blueGray600: '#475569',
  // blueGray700: '#334155',
  // blueGray800: '#1e293b',
  // blueGray900: '#0f172a',

};

/**
 * Global Tokens
 */

const typography = {
  fontFamily: {
    monospace: 'Consolas, Menlo, Monaco, "Andale Mono", "Ubuntu Mono", monospace',
    body: 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", sans-serif',
    heading: 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", sans-serif'
  },
  fontSize: {
    xxxsmall: '0.5rem',
    xxsmall: '0.6rem',
    xsmall: '0.75rem',
    small: '0.875rem',
    medium: '1rem',
    large: '1.125rem',
    xlarge: '1.25rem',
    xxlarge: '1.5rem',
    xxxlarge: '1.875rem',
    xxxxlarge: '2.25rem',
    xxxxxlarge: '3rem',
    xxxxxxlarge: '4rem'
  },
  fontWeight: {
    light: 300,
    regular: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    heavy: 800
  },
  leading: {
    tighter: 1,
    tight: 1.2,
    base: 1.4,
    loose: 1.6,
    looser: 1.8
  },
  tracking: {
    tighter: '-0.02em',
    tight: '-0.01em',
    base: '0em',
    loose: '0.01em',
    looser: '0.02em'
  }
};

const palette$1 = _objectSpread2({
  black: '#000000',
  white: '#ffffff',
  current: 'currentColor',
  transparent: 'transparent',
  neutral100: '#fafbfc',
  neutral200: '#eff3f6',
  neutral300: '#e1e5e9',
  neutral400: '#ccd1d5',
  neutral500: '#b1b5b9',
  neutral600: '#9ca3af',
  neutral700: '#6b7280',
  neutral800: '#374151',
  neutral900: '#111827'
}, palette);

const breakpoints = {
  small: 576,
  medium: 768,
  large: 992,
  xlarge: 1200
};
const elevation = {
  e100: 100,
  // Cards
  e200: 200,
  // Inline dialogs (popover)
  e300: 300,
  // Tooltip
  e400: 400,
  // Modals
  e500: 500 // Toasts (notifications)

};
const radii = {
  none: 0,
  xsmall: 4,
  small: 6,
  medium: 8,
  large: 12,
  full: 9999
};
const sizing = {
  xxsmall: 16,
  xsmall: 20,
  small: 24,
  medium: 32,
  large: 38,
  xlarge: 42,
  xxlarge: 48
};
const spacing = {
  none: 0,
  xxsmall: 2,
  xsmall: 4,
  small: 8,
  medium: 12,
  large: 16,
  xlarge: 24,
  xxlarge: 32
};
const shadow = {
  s100: `0px 1px 2px rgba(0, 0, 0, 0.2)`,
  // Cards
  s200: `0px 2px 4px rgba(0, 0, 0, 0.2)`,
  // Inline dialogs (popover)
  s300: `0px 2px 8px rgba(0, 0, 0, 0.2)`,
  // Tooltip
  s400: `0px 4px 16px rgba(0, 0, 0, 0.2)`,
  // Modals
  s500: `-8px 8px 32px rgba(0, 0, 0, 0.2)` // Toasts (notifications)

};
const animation = {
  duration0: '0ms',
  duration50: '40ms',
  duration100: '130ms',
  duration200: '160ms',
  duration300: '190ms',
  duration400: '220ms',
  duration500: '250ms',
  duration600: '300ms',
  duration700: '350ms',
  duration800: '400ms',
  duration900: '450ms',
  duration1000: '500ms',
  spring: `cubic-bezier(0.2, 0, 0, 1.6)`,
  easeInOut: 'cubic-bezier(.45, 0, .40, 1)',
  easeIn: `cubic-bezier(0.2, 0, 0, 1)`,
  easeOut: `cubic-bezier(0.165, 0.840, 0.440, 1)`,
  linear: 'cubic-bezier(0, 0, 1, 1)'
};
const opacity = {
  full: 1,
  none: 0,
  disabled: 0.65
};
/**
 * Alias Tokens
 */

const headingStyles = {
  h1: {
    color: palette$1.neutral900,
    family: typography.fontFamily.heading,
    size: typography.fontSize.xxxlarge,
    transform: 'none',
    weight: typography.fontWeight.heavy
  },
  h2: {
    color: palette$1.neutral900,
    family: typography.fontFamily.heading,
    size: typography.fontSize.xxlarge,
    transform: 'none',
    weight: typography.fontWeight.bold
  },
  h3: {
    color: palette$1.neutral900,
    family: typography.fontFamily.heading,
    size: typography.fontSize.xlarge,
    transform: 'none',
    weight: typography.fontWeight.bold
  },
  h4: {
    color: palette$1.neutral900,
    family: typography.fontFamily.heading,
    size: typography.fontSize.large,
    transform: 'none',
    weight: typography.fontWeight.bold
  },
  h5: {
    color: palette$1.neutral900,
    family: typography.fontFamily.heading,
    size: typography.fontSize.medium,
    transform: 'none',
    weight: typography.fontWeight.bold
  },
  h6: {
    color: palette$1.neutral900,
    family: typography.fontFamily.heading,
    size: typography.fontSize.small,
    transform: 'uppercase',
    weight: typography.fontWeight.bold
  }
};
const controlSizes = {
  small: {
    borderRadius: radii.xsmall,
    borderWidth: 1,
    gutter: spacing.xsmall,
    paddingX: spacing.medium,
    paddingY: spacing.xsmall,
    height: sizing.medium,
    gap: spacing.small,
    fontSize: typography.fontSize.small,
    indicatorBoxSize: sizing.xsmall,
    indicatorFontSize: typography.fontSize.xxxsmall
  },
  medium: {
    borderRadius: radii.small,
    borderWidth: 1,
    gutter: spacing.xsmall,
    paddingX: spacing.large,
    paddingY: spacing.xsmall,
    height: sizing.large,
    gap: spacing.medium,
    fontSize: typography.fontSize.medium,
    indicatorBoxSize: sizing.small,
    indicatorFontSize: typography.fontSize.xxsmall
  },
  large: {
    borderRadius: radii.medium,
    borderWidth: 1,
    gutter: spacing.small,
    paddingX: spacing.large,
    paddingY: spacing.small,
    height: sizing.xxlarge,
    gap: spacing.medium,
    fontSize: typography.fontSize.large,
    indicatorBoxSize: sizing.medium,
    indicatorFontSize: typography.fontSize.small
  }
};
const colors = {
  background: 'white',
  backgroundMuted: palette$1.neutral100,
  backgroundDim: palette$1.neutral200,
  border: palette$1.neutral300,
  borderCritical: palette$1.red400,
  borderFocus: palette$1.blue400,
  focusRing: palette$1.blue200,
  foreground: palette$1.neutral800,
  foregroundMuted: palette$1.neutral900,
  foregroundDim: palette$1.neutral700,
  foregroundDisabled: palette$1.neutral500,
  linkColor: palette$1.blue500,
  linkHoverColor: palette$1.blue600,
  overlayBackground: 'rgba(18,18,18, 0.3)',
  // blanket behind modal dialogs
  loaderDark: palette$1.neutral500,
  loaderLight: palette$1.neutral200
};
/**

Tones have 3 backgrounds:
- pass-through (colors.background or colors.backgroundMuted)
- tint (tone.tint)
- fill (tone.fill)

Tones have 2 foregrounds that should work on these backgrounds:
- foreground (should work on pass-through and tint)
- fillForeground (should work on fill)

*/

const tones = identityType()({
  active: {
    focusRing: palette$1.blue200,
    border: [palette$1.blue300, palette$1.blue400, palette$1.blue500],
    fill: [palette$1.blue600, palette$1.blue700, palette$1.blue800],
    tint: [palette$1.blue50, palette$1.blue100, palette$1.blue200],
    foreground: [palette$1.blue600, palette$1.blue700, palette$1.blue800],
    fillForeground: [palette$1.white, palette$1.white, palette$1.white]
  },
  passive: {
    focusRing: palette$1.neutral300,
    border: [palette$1.neutral300, palette$1.neutral400, palette$1.neutral500],
    fill: [palette$1.neutral600, palette$1.neutral700, palette$1.neutral800],
    tint: [palette$1.neutral200, palette$1.neutral300, palette$1.neutral400],
    foreground: [palette$1.neutral700, palette$1.neutral800, palette$1.neutral900],
    fillForeground: [palette$1.white, palette$1.white, palette$1.white]
  },
  positive: {
    focusRing: palette$1.green200,
    border: [palette$1.green300, palette$1.green400, palette$1.green500],
    fill: [palette$1.green600, palette$1.green700, palette$1.green800],
    tint: [palette$1.green50, palette$1.green100, palette$1.green200],
    foreground: [palette$1.green600, palette$1.green700, palette$1.green800],
    fillForeground: [palette$1.white, palette$1.white, palette$1.white]
  },
  warning: {
    focusRing: palette$1.yellow200,
    border: [palette$1.yellow300, palette$1.yellow400, palette$1.yellow500],
    fill: [palette$1.yellow400, palette$1.yellow500, palette$1.yellow600],
    tint: [palette$1.yellow50, palette$1.yellow100, palette$1.yellow200],
    foreground: [palette$1.yellow600, palette$1.yellow700, palette$1.yellow900],
    fillForeground: [palette$1.black, palette$1.black, palette$1.black]
  },
  negative: {
    focusRing: palette$1.red200,
    border: [palette$1.red300, palette$1.red400, palette$1.red500],
    fill: [palette$1.red500, palette$1.red600, palette$1.red700],
    tint: [palette$1.red50, palette$1.red100, palette$1.red200],
    foreground: [palette$1.red600, palette$1.red700, palette$1.red800],
    fillForeground: [palette$1.white, palette$1.white, palette$1.white]
  },
  help: {
    focusRing: palette$1.purple200,
    border: [palette$1.purple300, palette$1.purple400, palette$1.purple500],
    fill: [palette$1.purple500, palette$1.purple600, palette$1.purple700],
    tint: [palette$1.purple50, palette$1.purple100, palette$1.purple200],
    foreground: [palette$1.purple600, palette$1.purple700, palette$1.purple800],
    fillForeground: [palette$1.white, palette$1.white, palette$1.white]
  }
});
const selectableColors = identityType()({
  silver: {
    border: palette$1.neutral400,
    fill: palette$1.neutral500,
    fillForeground: 'white',
    foreground: palette$1.neutral600,
    tint: palette$1.neutral200
  },
  grey: {
    border: palette$1.neutral600,
    fill: palette$1.neutral700,
    fillForeground: 'white',
    foreground: palette$1.neutral700,
    tint: palette$1.neutral300
  },
  blue: {
    border: palette$1.blue400,
    fill: palette$1.blue500,
    fillForeground: 'white',
    foreground: palette$1.blue600,
    tint: palette$1.blue200
  },
  pink: {
    border: palette$1.pink400,
    fill: palette$1.pink500,
    fillForeground: 'white',
    foreground: palette$1.pink600,
    tint: palette$1.pink200
  },
  green: {
    border: palette$1.green400,
    fill: palette$1.green500,
    fillForeground: 'white',
    foreground: palette$1.green600,
    tint: palette$1.green200
  },
  purple: {
    border: palette$1.purple400,
    fill: palette$1.purple500,
    fillForeground: 'white',
    foreground: palette$1.purple600,
    tint: palette$1.purple200
  }
});
const fields = {
  controlBackground: 'white',
  controlBorderColor: palette$1.neutral300,
  controlBorderRadius: radii.small,
  controlBorderWidth: 2,
  controlForeground: palette$1.blue500,
  // iconColor: palette.neutral500, // TODO
  inputBackground: palette$1.neutral100,
  inputBorderColor: palette$1.neutral300,
  inputBorderRadius: radii.small,
  inputBorderWidth: 1,
  inputForeground: palette$1.neutral800,
  inputPlaceholder: palette$1.neutral500,
  labelColor: palette$1.neutral800,
  legendColor: palette$1.neutral600,
  switchForeground: 'white',
  hover: {
    inputBorderColor: palette$1.neutral400,
    controlBorderColor: palette$1.blue500
  },
  focus: {
    controlBorderColor: palette$1.blue500,
    inputBorderColor: palette$1.blue500,
    inputBackground: 'white',
    shadow: `0 0 0 2px ${colors.focusRing}`
  },
  disabled: {
    inputBackground: palette$1.neutral100,
    inputForeground: palette$1.neutral800,
    inputBorderColor: palette$1.transparent,
    controlBackground: palette$1.neutral100,
    controlBorderColor: palette$1.neutral200,
    controlForeground: palette$1.neutral500
  },
  invalid: {
    inputBackground: palette$1.red100,
    inputForeground: palette$1.neutral700,
    labelColor: palette$1.red600
  },
  selected: {
    controlBackground: palette$1.blue500,
    controlBorderColor: palette$1.blue500,
    controlForeground: 'white'
  }
};
/**
 * Export
 */

const theme = {
  name: 'Keystone: Light',
  // Global Tokens
  typography,
  palette: palette$1,
  breakpoints,
  elevation,
  radii,
  sizing,
  spacing,
  shadow,
  animation,
  opacity,
  // Alias Tokens
  headingStyles,
  controlSizes,
  colors,
  tones,
  selectableColors,
  fields
};

const ThemeContext = /*#__PURE__*/createContext({
  theme: theme
});
const ThemeProvider = ({
  theme,
  children
}) => {
  return /*#__PURE__*/React.createElement(ThemeContext.Provider, {
    value: {
      theme
    }
  }, children);
};
const useTheme = () => {
  const {
    theme
  } = useContext(ThemeContext);
  return theme;
};

/*
  Facepaint lets you write properties as arrays e.g.

  <div css={{ width: [200, 400] }} />

  More here: https://github.com/emotion-js/facepaint
*/
const makeMq = breakpoints => facepaint(Object.values(breakpoints).map(w => `@media (min-width: ${w}px)`)); // helper if array property declaration isn't appropriate


const makeMinBreak = breakpoints => key => {
  const width = breakpoints[key];
  return `@media (min-width: ${width}px)`;
}; // the breakpoints are designed to go up i.e. min-width
// if a max-width is necessary (hopefully rare) it's nice to provide a helper


const makeMaxBreak = breakpoints => key => {
  const width = breakpoints[key];
  return `@media (max-width: ${width - 1}px)`;
}; // FIXME:
// Should this even be a hook? I think we can just export these utilities...


const useMediaQuery = () => {
  const {
    breakpoints
  } = useTheme();
  return {
    mq: makeMq(breakpoints),
    maxBreak: makeMaxBreak(breakpoints),
    minBreak: makeMinBreak(breakpoints)
  };
};

// Style Functions
// ---------------
const useBoxStyles = ({
  background,
  foreground,
  height,
  margin,
  marginTop,
  marginRight,
  marginBottom,
  marginLeft,
  marginY,
  marginX,
  padding,
  paddingTop,
  paddingRight,
  paddingBottom,
  paddingLeft,
  paddingY,
  paddingX,
  rounding,
  roundingBottom,
  roundingLeft,
  roundingRight,
  roundingTop,
  textAlign,
  width
}) => {
  const theme = useTheme();
  const {
    mq
  } = useMediaQuery();
  const resolvedColors = useColors({
    background,
    foreground
  }, theme);
  const resolvedMargin = useMargin({
    margin,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    marginY,
    marginX
  }, theme);
  const resolvedPadding = usePadding({
    padding,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    paddingY,
    paddingX
  }, theme);
  const resolvedRounding = useRadii({
    rounding,
    roundingTop,
    roundingRight,
    roundingBottom,
    roundingLeft
  }, theme);
  return mq(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, resolvedColors), resolvedMargin), resolvedPadding), resolvedRounding), {}, {
    boxSizing: 'border-box',
    height: height,
    textAlign: textAlign,
    width: width
  }));
}; // Utils
// ------------------------------

function useColors({
  background,
  foreground
}, {
  palette
}) {
  return {
    backgroundColor: background && mapResponsiveProp(background, palette),
    color: foreground && mapResponsiveProp(foreground, palette)
  };
}

function useRadii({
  rounding,
  roundingTop,
  roundingRight,
  roundingBottom,
  roundingLeft
}, {
  radii
}) {
  let borderBottomLeftRadius = roundingBottom || roundingLeft || rounding;
  let borderBottomRightRadius = roundingBottom || roundingRight || rounding;
  let borderTopLeftRadius = roundingTop || roundingLeft || rounding;
  let borderTopRightRadius = roundingTop || roundingRight || rounding;
  return {
    borderBottomLeftRadius: borderBottomLeftRadius && mapResponsiveProp(borderBottomLeftRadius, radii),
    borderBottomRightRadius: borderBottomRightRadius && mapResponsiveProp(borderBottomRightRadius, radii),
    borderTopLeftRadius: borderTopLeftRadius && mapResponsiveProp(borderTopLeftRadius, radii),
    borderTopRightRadius: borderTopRightRadius && mapResponsiveProp(borderTopRightRadius, radii)
  };
}

function usePadding({
  padding,
  paddingTop,
  paddingRight,
  paddingBottom,
  paddingLeft,
  paddingY,
  paddingX
}, {
  spacing
}) {
  let pb = paddingBottom || paddingY || padding;
  let pt = paddingTop || paddingY || padding;
  let pl = paddingLeft || paddingX || padding;
  let pr = paddingRight || paddingX || padding;
  return {
    paddingBottom: pb && mapResponsiveProp(pb, spacing),
    paddingTop: pt && mapResponsiveProp(pt, spacing),
    paddingLeft: pl && mapResponsiveProp(pl, spacing),
    paddingRight: pr && mapResponsiveProp(pr, spacing)
  };
}

function useMargin({
  margin,
  marginTop,
  marginRight,
  marginBottom,
  marginLeft,
  marginY,
  marginX
}, {
  spacing
}) {
  let mb = marginBottom || marginY || margin;
  let mt = marginTop || marginY || margin;
  let ml = marginLeft || marginX || margin;
  let mr = marginRight || marginX || margin;
  return {
    marginBottom: mb && mapResponsiveProp(mb, spacing),
    marginTop: mt && mapResponsiveProp(mt, spacing),
    marginLeft: ml && mapResponsiveProp(ml, spacing),
    marginRight: mr && mapResponsiveProp(mr, spacing)
  };
} // Box Component
// -------------


const Box = forwardRefWithAs((_ref, ref) => {
  let {
    as: Tag = 'div'
  } = _ref,
      props = _objectWithoutProperties(_ref, ["as"]);

  const {
    background,
    foreground,
    height,
    margin,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    marginY,
    marginX,
    padding,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    paddingY,
    paddingX,
    rounding,
    roundingBottom,
    roundingLeft,
    roundingRight,
    roundingTop,
    textAlign,
    width
  } = props,
        attrs = _objectWithoutProperties(props, ["background", "foreground", "height", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginY", "marginX", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingY", "paddingX", "rounding", "roundingBottom", "roundingLeft", "roundingRight", "roundingTop", "textAlign", "width"]);

  const boxStyles = useBoxStyles({
    background,
    foreground,
    height,
    margin,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    marginY,
    marginX,
    padding,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    paddingY,
    paddingX,
    rounding,
    roundingBottom,
    roundingLeft,
    roundingRight,
    roundingTop,
    textAlign,
    width
  });
  return jsx(Tag, _extends({
    css: boxStyles,
    ref: ref
  }, attrs));
});

const normalize = css`
  /*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */
  html {
    line-height: 1.15;
    -webkit-text-size-adjust: 100%;
  }
  body {
    margin: 0;
  }
  main {
    display: block;
  }
  h1 {
    font-size: 2em;
    margin: 0.67em 0;
  }
  hr {
    box-sizing: content-box;
    height: 0;
    overflow: visible;
  }
  pre {
    font-family: monospace, monospace;
    font-size: 1em;
  }
  a {
    background-color: transparent;
  }
  abbr[title] {
    border-bottom: none;
    text-decoration: underline;
    text-decoration: underline dotted;
  }
  b,
  strong {
    font-weight: bolder;
  }
  code,
  kbd,
  samp {
    font-family: monospace, monospace;
    font-size: 1em;
  }
  small {
    font-size: 80%;
  }
  sub,
  sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
  }
  sub {
    bottom: -0.25em;
  }
  sup {
    top: -0.5em;
  }
  img {
    border-style: none;
  }
  button,
  input,
  optgroup,
  select,
  textarea {
    font-family: inherit;
    font-size: 100%;
    line-height: 1.15;
    margin: 0;
  }
  button:focus,
  input:focus,
  select:focus,
  textarea:focus {
    outline: none;
  }
  button,
  input {
    overflow: visible;
  }
  button,
  select {
    text-transform: none;
  }
  [type='button'],
  [type='reset'],
  [type='submit'],
  button {
    -webkit-appearance: button;
  }
  [type='button']::-moz-focus-inner,
  [type='reset']::-moz-focus-inner,
  [type='submit']::-moz-focus-inner,
  button::-moz-focus-inner {
    border-style: none;
    padding: 0;
  }
  [type='button']:-moz-focusring,
  [type='reset']:-moz-focusring,
  [type='submit']:-moz-focusring,
  button:-moz-focusring {
    outline: 1px dotted ButtonText;
  }
  fieldset {
    border: 0;
    margin: 0;
    padding: 0;
  }
  legend {
    box-sizing: border-box;
    color: inherit;
    display: table;
    max-width: 100%;
    padding: 0;
    white-space: normal;
  }
  progress {
    vertical-align: baseline;
  }
  textarea {
    overflow: auto;
  }
  [type='checkbox'],
  [type='radio'] {
    box-sizing: border-box;
    padding: 0;
  }
  [type='number']::-webkit-inner-spin-button,
  [type='number']::-webkit-outer-spin-button {
    height: auto;
  }
  [type='search'] {
    -webkit-appearance: textfield;
    outline-offset: -2px;
  }
  [type='search']::-webkit-search-decoration {
    -webkit-appearance: none;
  }
  ::-webkit-file-upload-button {
    -webkit-appearance: button;
    font: inherit;
  }
  details {
    display: block;
  }
  summary {
    display: list-item;
  }
  template {
    display: none;
  }
  [hidden] {
    display: none;
  }
`;

const Core = ({
  children,
  includeNormalize = true,
  optimizeLegibility = true
}) => {
  return jsx(Fragment, null, jsx(BaseCSS, {
    includeNormalize: includeNormalize,
    optimizeLegibility: optimizeLegibility
  }), children);
}; // Base CSS
// ------------------------------

const BaseCSS = ({
  includeNormalize,
  optimizeLegibility
}) => {
  const {
    typography,
    colors
  } = useTheme();
  return jsx(Fragment, null, includeNormalize && jsx(Global, {
    styles: normalize
  }), jsx(Global, {
    styles: {
      html: {
        fontSize: 'initial !important' // ensure user's font-size settings are observed, for rems

      },
      body: _objectSpread2({
        backgroundColor: colors.background,
        color: colors.foreground,
        fontSize: '1rem',
        fontWeight: typography.fontWeight.regular,
        lineHeight: typography.leading.base,
        fontFamily: typography.fontFamily.body
      }, optimizeLegibility && {
        fontFeatureSettings: '"liga" 1',
        // Enable OpenType ligatures in IE
        textRendering: 'optimizeLegibility',
        WebkitFontSmoothing: 'antialiased',
        MozOsxFontSmoothing: 'grayscale',
        MozFontFeatureSettings: '"liga" on'
      }),
      // Set correct default colors for links from the theme
      a: {
        color: colors.linkColor,
        ':hover': {
          color: colors.linkHoverColor
        }
      },
      // [1] reset all box sizing to border-box
      // [2] default borders so you can add a border by specifying just the width
      '*, ::before, ::after': {
        boxSizing: 'border-box',
        borderWidth: 0,
        borderStyle: 'solid',
        borderColor: colors.border
      }
    }
  }));
};

const Center = forwardRefWithAs((_ref, ref) => {
  let {
    fillView = false
  } = _ref,
      props = _objectWithoutProperties(_ref, ["fillView"]);

  return jsx(Box, _extends({
    ref: ref,
    css: {
      alignItems: 'center',
      display: 'flex',
      justifyContent: 'center',
      height: fillView ? '100vh' : undefined,
      width: fillView ? '100vw' : undefined
    }
  }, props));
});

const orientationMap = {
  horizontal: 'width',
  vertical: 'height'
};
const Divider = (_ref) => {
  let {
    orientation = 'vertical',
    color
  } = _ref,
      props = _objectWithoutProperties(_ref, ["orientation", "color"]);

  const {
    colors
  } = useTheme();
  const dimension = orientationMap[orientation];
  const styles = {
    // default the background color to the theme border color
    backgroundColor: color ? undefined : colors.border,
    flexShrink: 0,
    [dimension]: 1
  }; // if the color prop is defined, pass it as the background to the box

  return jsx(Box, _extends({
    css: styles,
    background: color
  }, props));
};

const Heading = forwardRefWithAs((_ref, ref) => {
  let {
    as = 'h1',
    type = 'h1'
  } = _ref,
      props = _objectWithoutProperties(_ref, ["as", "type"]);

  const {
    headingStyles
  } = useTheme();
  const headingStyle = headingStyles[type];
  const styles = {
    color: headingStyle.color,
    fontFamily: headingStyle.family,
    fontSize: headingStyle.size,
    fontWeight: headingStyle.weight,
    textTransform: headingStyle.transform,
    margin: 0
  };
  return jsx(Box, _extends({
    as: as,
    css: styles,
    ref: ref
  }, props));
});
const H1 = forwardRefWithAs((_ref2, ref) => {
  let {
    as = 'h1'
  } = _ref2,
      props = _objectWithoutProperties(_ref2, ["as"]);

  return jsx(Heading, _extends({
    ref: ref,
    as: as,
    type: "h1"
  }, props));
});
const H2 = forwardRefWithAs((_ref3, ref) => {
  let {
    as = 'h2'
  } = _ref3,
      props = _objectWithoutProperties(_ref3, ["as"]);

  return jsx(Heading, _extends({
    ref: ref,
    as: as,
    type: "h2"
  }, props));
});
const H3 = forwardRefWithAs((_ref4, ref) => {
  let {
    as = 'h3'
  } = _ref4,
      props = _objectWithoutProperties(_ref4, ["as"]);

  return jsx(Heading, _extends({
    ref: ref,
    as: as,
    type: "h3"
  }, props));
});
const H4 = forwardRefWithAs((_ref5, ref) => {
  let {
    as = 'h4'
  } = _ref5,
      props = _objectWithoutProperties(_ref5, ["as"]);

  return jsx(Heading, _extends({
    ref: ref,
    as: as,
    type: "h4"
  }, props));
});
const H5 = forwardRefWithAs((_ref6, ref) => {
  let {
    as = 'h5'
  } = _ref6,
      props = _objectWithoutProperties(_ref6, ["as"]);

  return jsx(Heading, _extends({
    ref: ref,
    as: as,
    type: "h5"
  }, props));
});
const H6 = forwardRefWithAs((_ref7, ref) => {
  let {
    as = 'h6'
  } = _ref7,
      props = _objectWithoutProperties(_ref7, ["as"]);

  return jsx(Heading, _extends({
    ref: ref,
    as: as,
    type: "h6"
  }, props));
});

const alignment = {
  center: 'center',
  end: 'flex-end',
  start: 'flex-start',
  stretch: 'stretch'
};
const Inline = forwardRefWithAs((_ref, ref) => {
  let {
    align = 'start',
    children,
    gap = 'none'
  } = _ref,
      props = _objectWithoutProperties(_ref, ["align", "children", "gap"]);

  const {
    spacing
  } = useTheme();
  const resolvedAlign = alignment[align];
  const resolvedGap = spacing[gap];
  return jsx(Box, _extends({
    css: {
      alignItems: resolvedAlign,
      display: 'flex',
      flexWrap: 'wrap',
      marginLeft: -resolvedGap,
      marginTop: -resolvedGap
    },
    ref: ref
  }, props), Children.map(children, child => child !== null && child !== undefined ? jsx("div", {
    css: {
      display: 'flex',
      flexWrap: 'wrap',
      paddingLeft: resolvedGap,
      paddingTop: resolvedGap
    }
  }, child) : null));
});

const Link = forwardRefWithAs((_ref, ref) => {
  let {
    as: Tag = 'a'
  } = _ref,
      props = _objectWithoutProperties(_ref, ["as"]);

  const {
    typography,
    colors
  } = useTheme();
  const styles = {
    color: colors.linkColor,
    cursor: 'pointer',
    fontWeight: typography.fontWeight.medium,
    textDecoration: 'none',
    ':hover, :focus': {
      color: colors.linkHoverColor,
      textDecoration: 'underline'
    }
  };
  return jsx(Tag, _extends({
    css: styles,
    ref: ref
  }, props));
});

const alignment$1 = {
  center: 'center',
  end: 'flex-end',
  start: 'flex-start',
  stretch: 'stretch'
};
const orientationMap$1 = {
  horizontal: {
    flexDirection: 'row',
    marginProperty: 'marginLeft',
    dimension: 'width'
  },
  vertical: {
    flexDirection: 'column',
    marginProperty: 'marginTop',
    dimension: 'height'
  }
};
const Stack = forwardRefWithAs((_ref, ref) => {
  let {
    across,
    align = 'stretch',
    children,
    dividers = 'none',
    gap = 'none'
  } = _ref,
      props = _objectWithoutProperties(_ref, ["across", "align", "children", "dividers", "gap"]);

  const {
    spacing
  } = useTheme();
  const {
    mq
  } = useMediaQuery();
  const orientation = across ? 'horizontal' : 'vertical';
  const {
    dimension,
    flexDirection,
    marginProperty
  } = orientationMap$1[orientation];
  return jsx(Box, _extends({
    ref: ref,
    css: mq({
      alignItems: alignment$1[align],
      display: 'flex',
      flexDirection,
      [dimension]: 'fit-content',
      '& > * + *': {
        [marginProperty]: mapResponsiveProp(gap, spacing)
      }
    })
  }, props), ['around', 'start'].includes(dividers) && jsx(Divider, {
    orientation: orientation
  }), Children.toArray(children).filter(child => /*#__PURE__*/isValidElement(child)).map((child, index) => {
    return jsx(Fragment, {
      key: index
    }, dividers !== 'none' && index ? jsx(Divider, {
      orientation: orientation
    }) : null, jsx("div", {
      css: {
        ':empty': {
          display: 'none'
        }
      }
    }, child));
  }), ['around', 'end'].includes(dividers) && jsx(Divider, {
    orientation: orientation
  }));
});

const Text = forwardRefWithAs((_ref, ref) => {
  let {
    color,
    leading = 'base',
    size = 'medium',
    tracking = 'base',
    weight = 'regular'
  } = _ref,
      props = _objectWithoutProperties(_ref, ["color", "leading", "size", "tracking", "weight"]);

  const {
    palette,
    typography
  } = useTheme();
  const {
    mq
  } = useMediaQuery();
  const styles = mq({
    color: color ? palette[color] : undefined,
    fontSize: typography.fontSize[size],
    fontWeight: typography.fontWeight[weight],
    letterSpacing: typography.tracking[tracking],
    lineHeight: typography.leading[leading]
  });
  return jsx(Box, _extends({
    css: styles,
    ref: ref
  }, props));
});

function useManagedState(controlledValue, defaultValue, onChange) {
  const {
    current: isControlled
  } = useRef(controlledValue !== undefined);
  const [internalValue, setInternalValue] = useState(defaultValue); // warn consumers when their component is switching from controlled to uncontrolled and vice versa

  devWarning(isControlled && controlledValue === undefined, 'A component is changing from controlled to uncontrolled. Check the `value` prop being passed in.');
  devWarning(!isControlled && controlledValue !== undefined, 'A component is changing from uncontrolled to controlled. Check the `value` prop being passed in.'); // handle value changes (both internal, and controlled)

  const setValue = (v, e) => {
    if (typeof onChange === 'function') {
      onChange(v, e);
    }

    setInternalValue(v);
  }; // determine which value to pass on


  const value = controlledValue !== undefined ? controlledValue : internalValue;
  return [value, setValue];
}

export { Box, Center, Core, Divider, H1, H2, H3, H4, H5, H6, Heading, Inline, Link, Portal, Stack, Text, ThemeContext, ThemeProvider, VisuallyHidden, devWarning, forwardRefWithAs, identityType, makeId, mapResponsiveProp, useId, useManagedState, useMediaQuery, useSafeLayoutEffect, useTheme };
