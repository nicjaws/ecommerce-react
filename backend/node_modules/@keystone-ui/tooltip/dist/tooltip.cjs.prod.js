'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var _extends = require('@babel/runtime/helpers/extends');
var react = require('react');
var applyRef = require('apply-ref');
var core = require('@keystone-ui/core');
var popover = require('@keystone-ui/popover');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _objectWithoutProperties__default = /*#__PURE__*/_interopDefault(_objectWithoutProperties);
var _extends__default = /*#__PURE__*/_interopDefault(_extends);

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const Tooltip = ({
  children,
  content,
  hideOnClick = true,
  placement = 'top',
  weight = 'bold'
}) => {
  const {
    spacing
  } = core.useTheme();
  const isBold = weight === 'bold';
  const {
    isOpen,
    setOpen,
    trigger,
    dialog,
    arrow
  } = popover.usePopover({
    placement,
    modifiers: [{
      name: 'offset',
      options: {
        offset: [0, isBold ? spacing.small : spacing.xsmall]
      }
    }]
  });
  const tooltipId = core.useId();
  const showTooltip = react.useCallback(() => setOpen(true), []);
  const hideTooltip = react.useCallback(() => setOpen(false), []);
  const internalRef = react.useRef(null); // avoid overriding the consumer's `onClick` handler

  react.useEffect(() => {
    const triggerEl = internalRef.current;

    if (hideOnClick && triggerEl) {
      triggerEl.addEventListener('click', hideTooltip);
      return () => triggerEl.removeEventListener('click', hideTooltip);
    }
  }, [isOpen]);
  return core.jsx(react.Fragment, null, react.useMemo(() => children({
    onMouseEnter: showTooltip,
    onMouseLeave: hideTooltip,
    onFocus: showTooltip,
    onBlur: hideTooltip,
    'aria-describedby': tooltipId,
    ref: applyRef.applyRefs(trigger.ref, internalRef)
  }), [children, showTooltip, hideTooltip, tooltipId, trigger.ref, internalRef]), core.jsx(TooltipElement, _extends__default['default']({
    id: tooltipId,
    isVisible: isOpen,
    weight: weight,
    ref: dialog.ref
  }, dialog.props, {
    arrow: weight === 'bold' ? arrow : undefined
  }), content));
}; // Styled Component
// ------------------------------

const TooltipElement = /*#__PURE__*/react.memo( /*#__PURE__*/react.forwardRef((_ref, consumerRef) => {
  let {
    isVisible,
    children,
    arrow,
    weight
  } = _ref,
      props = _objectWithoutProperties__default['default'](_ref, ["isVisible", "children", "arrow", "weight"]);

  const isBold = weight === 'bold';
  const {
    elevation,
    radii,
    colors,
    spacing,
    typography
  } = core.useTheme();
  const arrowStyles = useArrowStyles();
  return core.jsx(core.Portal, null, core.jsx("div", _extends__default['default']({
    role: "tooltip",
    "aria-hidden": !isVisible,
    ref: consumerRef,
    css: _objectSpread2({
      backgroundColor: colors.foregroundMuted,
      borderRadius: radii.xsmall,
      color: colors.background,
      fontSize: isBold ? typography.fontSize.small : typography.fontSize.xsmall,
      fontWeight: typography.fontWeight.medium,
      lineHeight: typography.leading.tight,
      maxWidth: 320,
      // less than desirable magic number, but not sure if this needs to be in theme...
      opacity: isVisible ? isBold ? 1 : 0.9 : 0,
      padding: isBold ? `${spacing.small}px ${spacing.medium}px` : `${spacing.xsmall}px ${spacing.small}px`,
      pointerEvents: isVisible ? undefined : 'none',
      zIndex: elevation.e500
    }, arrowStyles)
  }, props), children, arrow && core.jsx("div", _extends__default['default']({
    "data-popper-arrow": true,
    ref: arrow.ref,
    className: "tooltipArrow"
  }, arrow.props))));
}));

const useArrowStyles = () => {
  const {
    colors
  } = core.useTheme();
  return {
    '.tooltipArrow': {
      position: 'absolute',
      overflow: 'hidden',
      pointerEvents: 'none',
      height: '20px',
      width: '20px',
      '&::after': {
        content: 'close-quote',
        position: 'absolute',
        width: '10px',
        height: '10px',
        backgroundColor: colors.foregroundMuted,
        transform: 'translateX(-50%) translateY(-50%) rotate(45deg)'
      }
    },
    "&[data-popper-placement^='left'] > .tooltipArrow": {
      left: '100%',
      '&::after': {
        top: '50%',
        left: '0'
      }
    },
    "&[data-popper-placement^='right'] > .tooltipArrow": {
      right: '100%',
      '&::after': {
        top: '50%',
        left: '100%'
      }
    },
    "&[data-popper-placement^='top'] > .tooltipArrow": {
      top: '100%',
      '&::after': {
        top: 0,
        bottom: '-50%',
        left: '50%'
      }
    },
    "&[data-popper-placement^='bottom'] > .tooltipArrow": {
      bottom: '100%',
      right: 'unset',
      '&::after': {
        bottom: '-50%',
        left: '50%'
      }
    }
  };
};

exports.Tooltip = Tooltip;
