"use strict";

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _extends = require("@babel/runtime/helpers/extends"), _objectWithoutProperties = require("@babel/runtime/helpers/objectWithoutProperties"), react = require("react"), core = require("@keystone-ui/core");

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    default: e
  };
}

var _extends__default = _interopDefault(_extends), _objectWithoutProperties__default = _interopDefault(_objectWithoutProperties);

function _defineProperty(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value: value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

const widthMap = {
  small: 128,
  medium: 256,
  large: 512,
  full: "100%"
}, useControlTokens = ({size: sizeKey, width: widthKey}) => {
  const {controlSizes: controlSizes} = core.useTheme(), size = controlSizes[sizeKey], width = widthMap[widthKey];
  return {
    borderRadius: size.borderRadius,
    paddingX: size.gutter,
    paddingY: size.gutter,
    width: width
  };
}, SegmentedControl = _ref => {
  let {animate: animate = !1, fill: fill = !1, initialIndex: initialIndexProp = 0, onChange: onChangeProp, segments: segments, size: size = "medium", width: width = "large", selectedIndex: selectedIndexProp} = _ref, props = _objectWithoutProperties__default.default(_ref, [ "animate", "fill", "initialIndex", "onChange", "segments", "size", "width", "selectedIndex" ]);
  const rootRef = react.useRef(null), [selectedRect, setSelectedRect] = react.useState({}), [selectedIndex, setIndex] = core.useManagedState(selectedIndexProp, initialIndexProp, onChangeProp), name = String(core.useId());
  return react.useEffect((() => {
    if (animate && rootRef.current instanceof HTMLElement) {
      let selected = Array.from(rootRef.current.children)[selectedIndex], rootRect = rootRef.current.getBoundingClientRect(), nodeRect = selected.getBoundingClientRect(), offsetLeft = nodeRect.left - rootRect.left, offsetTop = nodeRect.top - rootRect.top;
      setSelectedRect({
        height: nodeRect.height,
        width: nodeRect.width,
        left: 0,
        top: 0,
        transform: `translateX(${offsetLeft}px) translateY(${offsetTop}px)`
      });
    }
  }), [ animate, selectedIndex ]), core.jsx(core.Box, props, core.jsx(Root, {
    fill: fill,
    size: size,
    ref: rootRef,
    width: width
  }, segments.map(((label, idx) => {
    const isSelected = selectedIndex === idx;
    return core.jsx(Item, {
      fill: fill,
      isAnimated: animate,
      isSelected: isSelected,
      key: label,
      name: name,
      onChange: (index = idx, event => {
        setIndex(index, event);
      }),
      size: size,
      value: idx
    }, label);
    var index;
  })), animate && core.jsx(SelectedIndicator, {
    size: size,
    style: selectedRect
  })));
}, Root = react.forwardRef(((_ref2, ref) => {
  let {fill: fill, size: size, width: width} = _ref2, props = _objectWithoutProperties__default.default(_ref2, [ "fill", "size", "width" ]);
  const {colors: colors} = core.useTheme(), tokens = useControlTokens({
    size: size,
    width: width
  });
  return core.jsx("div", _extends__default.default({
    ref: ref,
    css: {
      borderRadius: tokens.borderRadius,
      paddingLeft: tokens.paddingX,
      paddingRight: tokens.paddingX,
      paddingTop: tokens.paddingY,
      paddingBottom: tokens.paddingY,
      userSelect: "none",
      background: colors.backgroundDim,
      display: fill ? "flex" : "inline-flex",
      flexWrap: "wrap",
      maxWidth: tokens.width,
      justifyContent: "space-between",
      lineHeight: 1,
      position: "relative"
    }
  }, props));
})), Item = props => {
  const {children: children, fill: fill, isAnimated: isAnimated, isSelected: isSelected, onChange: onChange, size: size, value: value} = props, attrs = _objectWithoutProperties__default.default(props, [ "children", "fill", "isAnimated", "isSelected", "onChange", "size", "value" ]), {colors: colors, fields: fields, typography: typography} = core.useTheme(), sizeStyles = useItemSize(), selectedStyles = useSelectedStyles();
  return core.jsx("label", {
    css: _objectSpread2(_objectSpread2(_objectSpread2({}, sizeStyles[size]), !isAnimated && isSelected && selectedStyles), {}, {
      boxSizing: "border-box",
      cursor: "pointer",
      flex: fill ? 1 : void 0,
      fontWeight: typography.fontWeight.medium,
      textAlign: "center",
      position: "relative",
      zIndex: 2,
      ":hover": {
        color: isSelected ? void 0 : colors.linkHoverColor
      },
      ":active": {
        backgroundColor: isSelected ? void 0 : fields.hover.inputBackground
      }
    })
  }, core.jsx(core.VisuallyHidden, _extends__default.default({
    as: "input",
    type: "radio",
    onChange: onChange,
    value: value,
    checked: isSelected
  }, attrs)), children);
}, SelectedIndicator = _ref3 => {
  let {size: size} = _ref3, props = _objectWithoutProperties__default.default(_ref3, [ "size" ]);
  const sizeStyles = useItemSize(), selectedStyles = useSelectedStyles();
  return core.jsx("div", _extends__default.default({
    css: _objectSpread2(_objectSpread2(_objectSpread2({}, sizeStyles[size]), selectedStyles), {}, {
      boxSizing: "border-box",
      position: "absolute",
      transitionProperty: "height,transform,width",
      transitionDuration: "200ms",
      transitionTimingFunction: "cubic-bezier(.4,1,.75,.9)",
      zIndex: 1
    })
  }, props));
}, useItemSize = () => {
  const {spacing: spacing, typography: typography, radii: radii} = core.useTheme();
  return {
    small: {
      borderRadius: radii.xsmall,
      fontSize: typography.fontSize.small,
      paddingLeft: spacing.medium,
      paddingRight: spacing.medium,
      paddingBottom: spacing.small,
      paddingTop: spacing.small
    },
    medium: {
      borderRadius: radii.xsmall,
      fontSize: typography.fontSize.small,
      paddingLeft: spacing.medium,
      paddingRight: spacing.medium,
      paddingBottom: spacing.small,
      paddingTop: spacing.small
    },
    large: {
      borderRadius: radii.small,
      fontSize: typography.fontSize.medium,
      paddingLeft: spacing.large,
      paddingRight: spacing.large,
      paddingBottom: spacing.medium,
      paddingTop: spacing.medium
    }
  };
}, useSelectedStyles = () => {
  const {colors: colors, shadow: shadow} = core.useTheme();
  return {
    background: colors.background,
    boxShadow: shadow.s100
  };
};

exports.SegmentedControl = SegmentedControl;
