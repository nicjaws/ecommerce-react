'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('@babel/runtime/helpers/extends');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var react = require('react');
var core = require('@keystone-ui/core');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _extends__default = /*#__PURE__*/_interopDefault(_extends);
var _objectWithoutProperties__default = /*#__PURE__*/_interopDefault(_objectWithoutProperties);

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const widthMap = {
  small: 128,
  medium: 256,
  large: 512,
  full: '100%'
};
const useControlTokens = ({
  size: sizeKey,
  width: widthKey
}) => {
  const {
    controlSizes
  } = core.useTheme();
  const size = controlSizes[sizeKey];
  const width = widthMap[widthKey];
  return {
    borderRadius: size.borderRadius,
    paddingX: size.gutter,
    paddingY: size.gutter,
    width
  };
};

const SegmentedControl = (_ref) => {
  let {
    animate = false,
    fill = false,
    initialIndex: initialIndexProp = 0,
    onChange: onChangeProp,
    segments,
    size = 'medium',
    width = 'large',
    selectedIndex: selectedIndexProp
  } = _ref,
      props = _objectWithoutProperties__default['default'](_ref, ["animate", "fill", "initialIndex", "onChange", "segments", "size", "width", "selectedIndex"]);

  const rootRef = react.useRef(null);
  const [selectedRect, setSelectedRect] = react.useState({});
  const [selectedIndex, setIndex] = core.useManagedState(selectedIndexProp, initialIndexProp, onChangeProp);

  const handleChange = index => event => {
    setIndex(index, event);
  }; // Because we use radio buttons for the segments, they should share a unique `name`


  const name = String(core.useId()); // Animate the selected segment indicator

  react.useEffect(() => {
    if (animate && rootRef.current instanceof HTMLElement) {
      let nodes = Array.from(rootRef.current.children);
      let selected = nodes[selectedIndex];
      let rootRect = rootRef.current.getBoundingClientRect();
      let nodeRect = selected.getBoundingClientRect();
      let offsetLeft = nodeRect.left - rootRect.left;
      let offsetTop = nodeRect.top - rootRect.top;
      setSelectedRect({
        height: nodeRect.height,
        width: nodeRect.width,
        left: 0,
        top: 0,
        transform: `translateX(${offsetLeft}px) translateY(${offsetTop}px)`
      });
    }
  }, [animate, selectedIndex]);
  return core.jsx(core.Box, props, core.jsx(Root, {
    fill: fill,
    size: size,
    ref: rootRef,
    width: width
  }, segments.map((label, idx) => {
    const isSelected = selectedIndex === idx;
    return core.jsx(Item, {
      fill: fill,
      isAnimated: animate,
      isSelected: isSelected,
      key: label,
      name: name,
      onChange: handleChange(idx),
      size: size,
      value: idx
    }, label);
  }), animate && core.jsx(SelectedIndicator, {
    size: size,
    style: selectedRect
  })));
}; // Styled Components
// ------------------------------

const Root = /*#__PURE__*/react.forwardRef((_ref2, ref) => {
  let {
    fill,
    size,
    width
  } = _ref2,
      props = _objectWithoutProperties__default['default'](_ref2, ["fill", "size", "width"]);

  const {
    colors
  } = core.useTheme();
  const tokens = useControlTokens({
    size,
    width
  });
  return core.jsx("div", _extends__default['default']({
    ref: ref,
    css: {
      borderRadius: tokens.borderRadius,
      paddingLeft: tokens.paddingX,
      paddingRight: tokens.paddingX,
      paddingTop: tokens.paddingY,
      paddingBottom: tokens.paddingY,
      userSelect: 'none',
      // -- TODO
      background: colors.backgroundDim,
      display: fill ? 'flex' : 'inline-flex',
      flexWrap: 'wrap',
      maxWidth: tokens.width,
      justifyContent: 'space-between',
      lineHeight: 1,
      position: 'relative'
    }
  }, props));
});

const Item = props => {
  const {
    children,
    fill,
    isAnimated,
    isSelected,
    onChange,
    size,
    value
  } = props,
        attrs = _objectWithoutProperties__default['default'](props, ["children", "fill", "isAnimated", "isSelected", "onChange", "size", "value"]);

  const {
    colors,
    fields,
    typography
  } = core.useTheme();
  const sizeStyles = useItemSize();
  const selectedStyles = useSelectedStyles();
  return core.jsx("label", {
    css: _objectSpread2(_objectSpread2(_objectSpread2({}, sizeStyles[size]), !isAnimated && isSelected && selectedStyles), {}, {
      boxSizing: 'border-box',
      cursor: 'pointer',
      flex: fill ? 1 : undefined,
      fontWeight: typography.fontWeight.medium,
      textAlign: 'center',
      position: 'relative',
      zIndex: 2,
      ':hover': {
        color: !isSelected ? colors.linkHoverColor : undefined
      },
      ':active': {
        backgroundColor: !isSelected ? fields.hover.inputBackground : undefined
      }
    })
  }, core.jsx(core.VisuallyHidden, _extends__default['default']({
    as: "input",
    type: "radio",
    onChange: onChange,
    value: value,
    checked: isSelected
  }, attrs)), children);
};

const SelectedIndicator = (_ref3) => {
  let {
    size
  } = _ref3,
      props = _objectWithoutProperties__default['default'](_ref3, ["size"]);

  const sizeStyles = useItemSize();
  const selectedStyles = useSelectedStyles();
  return core.jsx("div", _extends__default['default']({
    css: _objectSpread2(_objectSpread2(_objectSpread2({}, sizeStyles[size]), selectedStyles), {}, {
      boxSizing: 'border-box',
      position: 'absolute',
      transitionProperty: 'height,transform,width',
      transitionDuration: '200ms',
      transitionTimingFunction: 'cubic-bezier(.4,1,.75,.9)',
      zIndex: 1
    })
  }, props));
}; // Utils
// ------------------------------


const useItemSize = () => {
  const {
    spacing,
    typography,
    radii
  } = core.useTheme();
  return {
    small: {
      borderRadius: radii.xsmall,
      fontSize: typography.fontSize.small,
      paddingLeft: spacing.medium,
      paddingRight: spacing.medium,
      paddingBottom: spacing.small,
      paddingTop: spacing.small
    },
    medium: {
      borderRadius: radii.xsmall,
      fontSize: typography.fontSize.small,
      paddingLeft: spacing.medium,
      paddingRight: spacing.medium,
      paddingBottom: spacing.small,
      paddingTop: spacing.small
    },
    large: {
      borderRadius: radii.small,
      fontSize: typography.fontSize.medium,
      paddingLeft: spacing.large,
      paddingRight: spacing.large,
      paddingBottom: spacing.medium,
      paddingTop: spacing.medium
    }
  };
};

const useSelectedStyles = () => {
  const {
    colors,
    shadow
  } = core.useTheme();
  return {
    background: colors.background,
    boxShadow: shadow.s100
  };
};

exports.SegmentedControl = SegmentedControl;
