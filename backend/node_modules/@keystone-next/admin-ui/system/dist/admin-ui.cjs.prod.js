'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs-extra');
var Path = require('path');
var fastGlob = require('fast-glob');
var prettier = require('prettier');
var resolve = require('resolve');
var templates_dist_adminUi = require('../../dist/index-46f2ebcf.cjs.prod.js');
var url = require('url');
var next = require('next');
var client = require('@apollo/client');
require('@emotion/hash');
require('graphql');
require('../../dist/admin-meta-graphql-5b37ade6.cjs.prod.js');
require('crypto');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefault(fs);
var Path__default = /*#__PURE__*/_interopDefault(Path);
var fastGlob__default = /*#__PURE__*/_interopDefault(fastGlob);
var prettier__default = /*#__PURE__*/_interopDefault(prettier);
var resolve__default = /*#__PURE__*/_interopDefault(resolve);
var url__default = /*#__PURE__*/_interopDefault(url);
var next__default = /*#__PURE__*/_interopDefault(next);

const formatSource = (src, parser = 'babel') => prettier__default['default'].format(src, {
  parser,
  trailingComma: 'es5',
  singleQuote: true
});

function getDoesAdminConfigExist() {
  try {
    const configPath = Path__default['default'].join(process.cwd(), 'admin', 'config');
    resolve__default['default'].sync(configPath, {
      extensions: ['.ts', '.tsx', '.js'],
      preserveSymlinks: false
    });
    return true;
  } catch (err) {
    if (err.code === 'MODULE_NOT_FOUND') {
      return false;
    }

    throw err;
  }
}

async function writeAdminFile(file, projectAdminPath) {
  const outputFilename = Path__default['default'].join(projectAdminPath, file.outputPath);

  if (file.mode === 'copy') {
    if (!Path__default['default'].isAbsolute(file.inputPath)) {
      throw new Error(`An inputPath of "${file.inputPath}" was provided to copy but inputPaths must be absolute`);
    }

    await fs__default['default'].ensureDir(Path__default['default'].dirname(outputFilename)); // TODO: should we use copyFile or copy?

    await fs__default['default'].copyFile(file.inputPath, outputFilename);
  }

  if (file.mode === 'write') {
    await fs__default['default'].outputFile(outputFilename, formatSource(file.src));
  }

  return Path__default['default'].normalize(outputFilename);
}

const generateAdminUI = async (config, graphQLSchema, keystone, projectAdminPath) => {
  var _config$ui$getAdditio, _config$ui, _config$ui$getAdditio2;

  // Nuke any existing files in our target directory
  await fs__default['default'].remove(projectAdminPath); // Write out the files configured by the user

  const userPages = (_config$ui$getAdditio = (_config$ui = config.ui) === null || _config$ui === void 0 ? void 0 : (_config$ui$getAdditio2 = _config$ui.getAdditionalFiles) === null || _config$ui$getAdditio2 === void 0 ? void 0 : _config$ui$getAdditio2.map(x => x(config))) !== null && _config$ui$getAdditio !== void 0 ? _config$ui$getAdditio : [];
  const userFilesToWrite = (await Promise.all(userPages)).flat();
  const savedFiles = await Promise.all(userFilesToWrite.map(file => writeAdminFile(file, projectAdminPath)));
  const uniqueFiles = new Set(savedFiles); // Write out the built-in admin UI files. Don't overwrite any user-defined pages.

  const configFileExists = getDoesAdminConfigExist();
  const adminFiles = templates_dist_adminUi.writeAdminFiles(config, graphQLSchema, keystone, configFileExists, projectAdminPath);
  const baseFiles = adminFiles.filter(x => !uniqueFiles.has(Path__default['default'].normalize(x.outputPath))); // FIXME: This path corresponds to the hardcoded value in CONFIG_PATH

  const configModule = Path__default['default'].join(projectAdminPath, '..', '..', 'keystone');
  const outputDir = Path__default['default'].join('pages', 'api');
  const pathToConfig = Path__default['default'].relative(Path__default['default'].join(projectAdminPath, outputDir), configModule); // this should always exist, the user should not be able to override it.

  baseFiles.push({
    mode: 'write',
    outputPath: Path__default['default'].join(outputDir, '__keystone_api_build.js'),
    src: `
    export { default as config } from '${pathToConfig}'
    export default function (req, res) {
      return res.status(500)
    }`
  });
  await Promise.all(baseFiles.map(file => writeAdminFile(file, projectAdminPath))); // Add files to pages/ which point to any files which exist in admin/pages

  const userPagesDir = Path__default['default'].join(process.cwd(), 'admin', 'pages');
  const files = await fastGlob__default['default']('**/*.{js,jsx,ts,tsx}', {
    cwd: userPagesDir
  });
  await Promise.all(files.map(async filename => {
    const outputFilename = Path__default['default'].join(projectAdminPath, 'pages', filename);
    const path = Path__default['default'].relative(Path__default['default'].dirname(outputFilename), Path__default['default'].join(userPagesDir, filename)); // Convert filesystem path separator to the `/` expected in JS imports

    const importPath = path.replace(new RegExp(`\\${Path__default['default'].sep}`, 'g'), '/');
    await fs__default['default'].outputFile(outputFilename, `export { default } from "${importPath}"`);
  }));
};

const createAdminUIServer = async (ui, createContext, dev, projectAdminPath, sessionImplementation) => {
  var _ui$publicPages;

  const app = next__default['default']({
    dev,
    dir: projectAdminPath
  });
  const handle = app.getRequestHandler();
  await app.prepare();
  const publicPages = (_ui$publicPages = ui === null || ui === void 0 ? void 0 : ui.publicPages) !== null && _ui$publicPages !== void 0 ? _ui$publicPages : [];
  return async (req, res) => {
    var _ui$pageMiddleware;

    const {
      pathname
    } = url__default['default'].parse(req.url);

    if (pathname !== null && pathname !== void 0 && pathname.startsWith('/_next')) {
      handle(req, res);
      return;
    }

    const context = createContext({
      sessionContext: await (sessionImplementation === null || sessionImplementation === void 0 ? void 0 : sessionImplementation.createSessionContext(req, res, createContext))
    });
    const isValidSession = ui !== null && ui !== void 0 && ui.isAccessAllowed ? await ui.isAccessAllowed(context) : context.session !== undefined;
    const maybeRedirect = await (ui === null || ui === void 0 ? void 0 : (_ui$pageMiddleware = ui.pageMiddleware) === null || _ui$pageMiddleware === void 0 ? void 0 : _ui$pageMiddleware.call(ui, {
      req,
      session: context.session,
      isValidSession,
      createContext
    }));

    if (maybeRedirect) {
      res.redirect(maybeRedirect.to);
      return;
    }

    if (!isValidSession && !publicPages.includes(url__default['default'].parse(req.url).pathname)) {
      app.render(req, res, '/no-access');
    } else {
      handle(req, res);
    }
  };
};

function createAdminMeta(config, keystone) {
  const {
    ui,
    lists,
    session
  } = config;
  const adminMetaRoot = {
    enableSessionItem: (ui === null || ui === void 0 ? void 0 : ui.enableSessionItem) || false,
    enableSignout: session !== undefined,
    listsByKey: {},
    lists: []
  };
  Object.keys(lists).forEach(key => {
    var _ref, _listConfig$ui, _ref2, _listConfig$ui$descri, _listConfig$ui2, _listConfig$ui$listVi, _listConfig$ui3, _listConfig$ui3$listV, _ref3, _listConfig$ui4, _listConfig$ui4$listV, _ref4, _listConfig$ui5, _listConfig$ui5$listV;

    const listConfig = lists[key];
    const list = keystone.lists[key]; // Default the labelField to `name`, `label`, or `title` if they exist; otherwise fall back to `id`

    const labelField = (_ref = (_listConfig$ui = listConfig.ui) === null || _listConfig$ui === void 0 ? void 0 : _listConfig$ui.labelField) !== null && _ref !== void 0 ? _ref : listConfig.fields.label ? 'label' : listConfig.fields.name ? 'name' : listConfig.fields.title ? 'title' : 'id';
    adminMetaRoot.listsByKey[key] = {
      key,
      labelField,
      description: (_ref2 = (_listConfig$ui$descri = (_listConfig$ui2 = listConfig.ui) === null || _listConfig$ui2 === void 0 ? void 0 : _listConfig$ui2.description) !== null && _listConfig$ui$descri !== void 0 ? _listConfig$ui$descri : listConfig.description) !== null && _ref2 !== void 0 ? _ref2 : null,
      label: list.adminUILabels.label,
      singular: list.adminUILabels.singular,
      plural: list.adminUILabels.plural,
      path: list.adminUILabels.path,
      fields: [],
      pageSize: (_listConfig$ui$listVi = (_listConfig$ui3 = listConfig.ui) === null || _listConfig$ui3 === void 0 ? void 0 : (_listConfig$ui3$listV = _listConfig$ui3.listView) === null || _listConfig$ui3$listV === void 0 ? void 0 : _listConfig$ui3$listV.pageSize) !== null && _listConfig$ui$listVi !== void 0 ? _listConfig$ui$listVi : 50,
      initialColumns: (_ref3 = (_listConfig$ui4 = listConfig.ui) === null || _listConfig$ui4 === void 0 ? void 0 : (_listConfig$ui4$listV = _listConfig$ui4.listView) === null || _listConfig$ui4$listV === void 0 ? void 0 : _listConfig$ui4$listV.initialColumns) !== null && _ref3 !== void 0 ? _ref3 : [labelField],
      initialSort: (_ref4 = (_listConfig$ui5 = listConfig.ui) === null || _listConfig$ui5 === void 0 ? void 0 : (_listConfig$ui5$listV = _listConfig$ui5.listView) === null || _listConfig$ui5$listV === void 0 ? void 0 : _listConfig$ui5$listV.initialSort) !== null && _ref4 !== void 0 ? _ref4 : null,
      itemQueryName: list.gqlNames.itemQueryName,
      listQueryName: list.gqlNames.listQueryName.replace('all', '')
    };
    adminMetaRoot.lists.push(adminMetaRoot.listsByKey[key]);
  }); // Populate .fields array

  Object.keys(lists).forEach(key => {
    const listConfig = lists[key];
    const list = keystone.lists[key];

    for (const fieldKey of Object.keys(listConfig.fields).filter(path => {
      var _listConfig$fields$pa;

      return ((_listConfig$fields$pa = listConfig.fields[path].config.access) === null || _listConfig$fields$pa === void 0 ? void 0 : _listConfig$fields$pa.read) !== false;
    })) {
      var _field$config$ui, _field$getAdminMeta, _field$getAdminMeta2;

      const field = listConfig.fields[fieldKey];
      adminMetaRoot.listsByKey[key].fields.push({
        label: list.fieldsByPath[fieldKey].label,
        viewsHash: templates_dist_adminUi.viewHash(field.views),
        customViewsHash: ((_field$config$ui = field.config.ui) === null || _field$config$ui === void 0 ? void 0 : _field$config$ui.views) === undefined ? null : templates_dist_adminUi.viewHash(field.config.ui.views),
        fieldMeta: (_field$getAdminMeta = (_field$getAdminMeta2 = field.getAdminMeta) === null || _field$getAdminMeta2 === void 0 ? void 0 : _field$getAdminMeta2.call(field, key, fieldKey, adminMetaRoot)) !== null && _field$getAdminMeta !== void 0 ? _field$getAdminMeta : null,
        isOrderable: list.fieldsByPath[fieldKey].isOrderable || fieldKey === 'id',
        path: fieldKey,
        listKey: key
      });
    }
  });
  return adminMetaRoot;
}

let typeDefs = client.gql`
  type Query {
    keystone: KeystoneMeta!
  }
  type KeystoneMeta {
    adminMeta: KeystoneAdminMeta!
  }

  type KeystoneAdminMeta {
    enableSignout: Boolean!
    enableSessionItem: Boolean!
    lists: [KeystoneAdminUIListMeta!]!
    list(key: String!): KeystoneAdminUIListMeta
  }

  type KeystoneAdminUIListMeta {
    key: String!
    itemQueryName: String!
    listQueryName: String!
    hideCreate: Boolean!
    hideDelete: Boolean!
    path: String!
    label: String!
    singular: String!
    plural: String!
    description: String
    initialColumns: [String!]!
    pageSize: Int!
    labelField: String!
    fields: [KeystoneAdminUIFieldMeta!]!
    initialSort: KeystoneAdminUISort
    isHidden: Boolean!
  }

  type KeystoneAdminUISort {
    field: String!
    direction: KeystoneAdminUISortDirection!
  }

  type KeystoneAdminUIFieldMeta {
    path: String!
    label: String!
    isOrderable: Boolean!
    fieldMeta: JSON
    viewsHash: String!
    customViewsHash: String
    createView: KeystoneAdminUIFieldMetaCreateView!
    listView: KeystoneAdminUIFieldMetaListView!
    itemView(id: ID!): KeystoneAdminUIFieldMetaItemView
  }

  type KeystoneAdminUIFieldMetaCreateView {
    fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
  }
  type KeystoneAdminUIFieldMetaListView {
    fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
  }
  type KeystoneAdminUIFieldMetaItemView {
    fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode!
  }

  enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
    edit
    hidden
  }
  enum KeystoneAdminUIFieldMetaListViewFieldMode {
    read
    hidden
  }
  enum KeystoneAdminUIFieldMetaItemViewFieldMode {
    edit
    read
    hidden
  }
  enum KeystoneAdminUISortDirection {
    ASC
    DESC
  }
`;
function getAdminMetaSchema({
  keystone,
  config
}) {
  var _config$ui$isAccessAl, _config$ui;

  const adminMetaRoot = createAdminMeta(config, keystone);
  const isAccessAllowed = config.session === undefined ? undefined : (_config$ui$isAccessAl = (_config$ui = config.ui) === null || _config$ui === void 0 ? void 0 : _config$ui.isAccessAllowed) !== null && _config$ui$isAccessAl !== void 0 ? _config$ui$isAccessAl : ({
    session
  }) => session !== undefined;
  return {
    typeDefs,
    resolvers: {
      Query: {
        keystone() {
          return {};
        }

      },
      KeystoneMeta: {
        adminMeta(rootVal, args, context) {
          if ('isAdminUIBuildProcess' in context || isAccessAllowed === undefined) {
            return adminMetaRoot;
          }

          return Promise.resolve(isAccessAllowed(context)).then(isAllowed => {
            if (isAllowed) {
              return adminMetaRoot;
            } // TODO: ughhhhhh, we really need to talk about errors.
            // mostly unrelated to above: error or return null here(+ make field nullable)?s


            throw new Error('Access denied');
          });
        }

      },
      KeystoneAdminMeta: {
        list(rootVal, args) {
          return rootVal.listsByKey[args.key];
        }

      },
      KeystoneAdminUIListMeta: {
        isHidden(rootVal, args, {
          session
        }) {
          var _listConfig$ui;

          const listConfig = config.lists[rootVal.key];
          return runMaybeFunction((_listConfig$ui = listConfig.ui) === null || _listConfig$ui === void 0 ? void 0 : _listConfig$ui.isHidden, false, {
            session
          });
        },

        hideDelete(rootVal, args, {
          session
        }) {
          var _listConfig$ui2;

          const listConfig = config.lists[rootVal.key];
          return runMaybeFunction((_listConfig$ui2 = listConfig.ui) === null || _listConfig$ui2 === void 0 ? void 0 : _listConfig$ui2.hideDelete, false, {
            session
          });
        },

        hideCreate(rootVal, args, {
          session
        }) {
          var _listConfig$ui3;

          const listConfig = config.lists[rootVal.key];
          return runMaybeFunction((_listConfig$ui3 = listConfig.ui) === null || _listConfig$ui3 === void 0 ? void 0 : _listConfig$ui3.hideCreate, false, {
            session
          });
        }

      },
      KeystoneAdminUIFieldMeta: {
        createView(rootVal) {
          return {
            fieldPath: rootVal.path,
            listKey: rootVal.listKey
          };
        },

        listView(rootVal) {
          return {
            fieldPath: rootVal.path,
            listKey: rootVal.listKey
          };
        },

        itemView(rootVal, args) {
          return {
            listKey: rootVal.listKey,
            fieldPath: rootVal.path,
            itemId: args.id
          };
        }

      },
      KeystoneAdminUIFieldMetaCreateView: {
        fieldMode(rootVal, args, {
          session
        }) {
          var _listConfig$fields$ro, _listConfig$fields$ro2, _listConfig$fields$ro3, _listConfig$ui4, _listConfig$ui4$creat;

          const listConfig = config.lists[rootVal.listKey];
          const sessionFunction = (_listConfig$fields$ro = (_listConfig$fields$ro2 = listConfig.fields[rootVal.fieldPath].config.ui) === null || _listConfig$fields$ro2 === void 0 ? void 0 : (_listConfig$fields$ro3 = _listConfig$fields$ro2.createView) === null || _listConfig$fields$ro3 === void 0 ? void 0 : _listConfig$fields$ro3.fieldMode) !== null && _listConfig$fields$ro !== void 0 ? _listConfig$fields$ro : (_listConfig$ui4 = listConfig.ui) === null || _listConfig$ui4 === void 0 ? void 0 : (_listConfig$ui4$creat = _listConfig$ui4.createView) === null || _listConfig$ui4$creat === void 0 ? void 0 : _listConfig$ui4$creat.defaultFieldMode;
          return runMaybeFunction(sessionFunction, 'edit', {
            session
          });
        }

      },
      KeystoneAdminUIFieldMetaListView: {
        fieldMode(rootVal, args, {
          session
        }) {
          var _listConfig$fields$ro4, _listConfig$fields$ro5, _listConfig$fields$ro6, _listConfig$ui5, _listConfig$ui5$listV;

          const listConfig = config.lists[rootVal.listKey];
          const sessionFunction = (_listConfig$fields$ro4 = (_listConfig$fields$ro5 = listConfig.fields[rootVal.fieldPath].config.ui) === null || _listConfig$fields$ro5 === void 0 ? void 0 : (_listConfig$fields$ro6 = _listConfig$fields$ro5.listView) === null || _listConfig$fields$ro6 === void 0 ? void 0 : _listConfig$fields$ro6.fieldMode) !== null && _listConfig$fields$ro4 !== void 0 ? _listConfig$fields$ro4 : (_listConfig$ui5 = listConfig.ui) === null || _listConfig$ui5 === void 0 ? void 0 : (_listConfig$ui5$listV = _listConfig$ui5.listView) === null || _listConfig$ui5$listV === void 0 ? void 0 : _listConfig$ui5$listV.defaultFieldMode;
          return runMaybeFunction(sessionFunction, 'read', {
            session
          });
        }

      },
      KeystoneAdminUIFieldMetaItemView: {
        async fieldMode(rootVal, args, context) {
          var _listConfig$fields$ro7, _listConfig$fields$ro8, _listConfig$fields$ro9, _listConfig$ui6, _listConfig$ui6$itemV;

          const item = await context.createContext({
            skipAccessControl: true
          }).lists[rootVal.listKey].findOne({
            where: {
              id: rootVal.itemId
            },
            resolveFields: false
          });
          const listConfig = config.lists[rootVal.listKey];
          const sessionFunction = (_listConfig$fields$ro7 = (_listConfig$fields$ro8 = listConfig.fields[rootVal.fieldPath].config.ui) === null || _listConfig$fields$ro8 === void 0 ? void 0 : (_listConfig$fields$ro9 = _listConfig$fields$ro8.itemView) === null || _listConfig$fields$ro9 === void 0 ? void 0 : _listConfig$fields$ro9.fieldMode) !== null && _listConfig$fields$ro7 !== void 0 ? _listConfig$fields$ro7 : (_listConfig$ui6 = listConfig.ui) === null || _listConfig$ui6 === void 0 ? void 0 : (_listConfig$ui6$itemV = _listConfig$ui6.itemView) === null || _listConfig$ui6$itemV === void 0 ? void 0 : _listConfig$ui6$itemV.defaultFieldMode;
          return runMaybeFunction(sessionFunction, 'edit', {
            session: context.session,
            item
          });
        }

      }
    }
  };
}

function runMaybeFunction(sessionFunction, defaultValue, args) {
  if (typeof sessionFunction === 'function') {
    return sessionFunction(args);
  }

  if (typeof sessionFunction === 'undefined') {
    return defaultValue;
  }

  return sessionFunction;
}

async function buildAdminUI(projectAdminPath) {
  // importing next/dist/build is quite expensive so we're requiring it lazily
  const build = require('next/dist/build').default;

  await build(projectAdminPath);
}

exports.buildAdminUI = buildAdminUI;
exports.createAdminUIServer = createAdminUIServer;
exports.generateAdminUI = generateAdminUI;
exports.getAdminMetaSchema = getAdminMetaSchema;
