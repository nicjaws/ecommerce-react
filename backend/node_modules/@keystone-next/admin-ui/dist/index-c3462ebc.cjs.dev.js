'use strict';

var hashString = require('@emotion/hash');
var graphql = require('graphql');
var adminMetaGraphql = require('./admin-meta-graphql-579d6879.cjs.dev.js');
var crypto = require('crypto');
var Path = require('path');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var hashString__default = /*#__PURE__*/_interopDefault(hashString);
var crypto__default = /*#__PURE__*/_interopDefault(crypto);
var Path__default = /*#__PURE__*/_interopDefault(Path);

const viewHash = views => `view${crypto__default['default'].createHash('sha256').update(views).digest('hex').slice(0, 8)}`;

const appTemplate = (config, graphQLSchema, {
  configFileExists,
  projectAdminPath
}) => {
  const result = graphql.executeSync({
    document: adminMetaGraphql.staticAdminMetaQuery,
    schema: graphQLSchema,
    contextValue: {
      isAdminUIBuildProcess: true
    }
  });

  if (result.errors) {
    throw result.errors[0];
  }

  const {
    adminMeta
  } = result.data.keystone;
  const adminMetaQueryResultHash = hashString__default['default'](JSON.stringify(adminMeta));

  const _allViews = new Set();

  Object.values(config.lists).forEach(list => {
    for (const fieldKey of Object.keys(list.fields)) {
      var _field$config$ui;

      const field = list.fields[fieldKey];

      _allViews.add(field.views);

      if ((_field$config$ui = field.config.ui) !== null && _field$config$ui !== void 0 && _field$config$ui.views) {
        _allViews.add(field.config.ui.views);
      }
    }
  });
  const allViews = [..._allViews];
  const viewPaths = {};

  for (const views of allViews) {
    const viewPath = Path__default['default'].isAbsolute(views) ? Path__default['default'].relative(Path__default['default'].join(projectAdminPath, 'pages'), views) : views; // Convert filesystem path separator to the `/` expected in JS imports

    viewPaths[views] = viewPath.replace(new RegExp(`\\${Path__default['default'].sep}`, 'g'), '/');
  } // -- TEMPLATE START


  return `
import React from 'react';

import { KeystoneProvider } from '@keystone-next/admin-ui/context';
import { ErrorBoundary } from '@keystone-next/admin-ui/components';
import { Core } from '@keystone-ui/core';

${allViews.map(views => `import * as ${viewHash(views)} from "${viewPaths[views]}"`).join('\n')}

${configFileExists ? `import * as adminConfig from "../../../admin/config";` : 'const adminConfig = {};'}

const fieldViews = {${allViews.map(viewHash)}};

const lazyMetadataQuery = ${JSON.stringify(getLazyMetadataQuery(graphQLSchema, adminMeta))};

export default function App({ Component, pageProps }) {
  return (
    <Core>
      <KeystoneProvider
        adminConfig={adminConfig}
        adminMetaHash="${adminMetaQueryResultHash}"
        fieldViews={fieldViews}
        lazyMetadataQuery={lazyMetadataQuery}
      >
        <ErrorBoundary>
          <Component {...pageProps} />
        </ErrorBoundary>
      </KeystoneProvider>
    </Core>
  );
}
  `; // -- TEMPLATE END
};

function getLazyMetadataQuery(graphqlSchema, adminMeta) {
  const selections = graphql.parse(`fragment x on y {
    keystone {
      adminMeta {
        lists {
          key
          isHidden
          fields {
            path
            createView {
              fieldMode
            }
          }
        }
      }
    }
  }`).definitions[0].selectionSet.selections;
  const queryType = graphqlSchema.getQueryType();

  if (queryType) {
    const getListByKey = name => adminMeta.lists.find(({
      key
    }) => key === name);

    const fields = queryType.getFields();

    if (fields['authenticatedItem'] !== undefined) {
      const authenticatedItemType = fields['authenticatedItem'].type;

      if (!(authenticatedItemType instanceof graphql.GraphQLUnionType) || authenticatedItemType.name !== 'AuthenticatedItem') {
        throw new Error(`The type of Query.authenticatedItem must be a type named AuthenticatedItem and be a union of types that refer to Keystone lists but it is "${authenticatedItemType.toString()}"`);
      }

      for (const type of authenticatedItemType.getTypes()) {
        const fields = type.getFields();
        const list = getListByKey(type.name);

        if (list === undefined) {
          throw new Error(`All members of the AuthenticatedItem union must refer to Keystone lists but "${type.name}" is in the AuthenticatedItem union but is not a Keystone list`);
        }

        let labelGraphQLField = fields[list.labelField];

        if (labelGraphQLField === undefined) {
          throw new Error(`The labelField for the list "${list.key}" is "${list.labelField}" but the GraphQL type does not have a field named "${list.labelField}"`);
        }

        let labelGraphQLFieldType = labelGraphQLField.type;

        if (labelGraphQLFieldType instanceof graphql.GraphQLNonNull) {
          labelGraphQLFieldType = labelGraphQLFieldType.ofType;
        }

        if (!(labelGraphQLFieldType instanceof graphql.GraphQLScalarType)) {
          throw new Error(`Label fields must be scalar GraphQL types but the labelField "${list.labelField}" on the list "${list.key}" is not a scalar type`);
        }

        const requiredArgs = labelGraphQLField.args.filter(arg => arg.defaultValue === undefined && arg.type instanceof graphql.GraphQLNonNull);

        if (requiredArgs.length) {
          throw new Error(`Label fields must have no required arguments but the labelField "${list.labelField}" on the list "${list.key}" has a required argument "${requiredArgs[0].name}"`);
        }
      }

      selections.push({
        kind: 'Field',
        name: {
          kind: 'Name',
          value: 'authenticatedItem'
        },
        selectionSet: {
          kind: 'SelectionSet',
          selections: authenticatedItemType.getTypes().map(({
            name
          }) => ({
            kind: 'InlineFragment',
            typeCondition: {
              kind: 'NamedType',
              name: {
                kind: 'Name',
                value: name
              }
            },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [{
                kind: 'Field',
                name: {
                  kind: 'Name',
                  value: 'id'
                }
              }, {
                kind: 'Field',
                name: {
                  kind: 'Name',
                  value: getListByKey(name).labelField
                }
              }]
            }
          }))
        }
      });
    }
  } // We're returning the complete query AST here for explicit-ness


  return {
    kind: 'Document',
    definitions: [{
      kind: 'OperationDefinition',
      operation: 'query',
      selectionSet: {
        kind: 'SelectionSet',
        selections
      }
    }]
  };
}

const homeTemplate = lists => `
import React from 'react';

import { HomePage } from '@keystone-next/admin-ui/pages/HomePage';
import { gql } from '@keystone-next/admin-ui/apollo';

export default function Home() {
  return <HomePage query={gql\`
    query {
      keystone {
        adminMeta {
          lists {
            key
            fields {
              path
              createView {
                fieldMode
              }
            }
          }
        }
      }
      ${Object.entries(lists).map(([listKey, list]) => `${listKey}: ${list.gqlNames.listQueryMetaName} { count }`).join('\n')}
    }\`} />;
}`;

const listTemplate = listKey => `
import React from 'react';

import { ListPage } from '@keystone-next/admin-ui/pages/ListPage';

export default function List() {
  return <ListPage listKey="${listKey}" />;
}
  `;

const itemTemplate = listKey => `
import React from 'react';

import { ItemPage } from '@keystone-next/admin-ui/pages/ItemPage';

export default function Item() {
  return <ItemPage listKey="${listKey}" />;
}
  `;

const noAccessTemplate = session => `
import React from 'react';

import { NoAccessPage } from '@keystone-next/admin-ui/pages/NoAccessPage';

export default function Home() {
  return <NoAccessPage sessionsEnabled={${!!session}} />;
}
  `;

const pkgDir = Path.dirname(require.resolve('@keystone-next/admin-ui/package.json'));
const writeAdminFiles = (config, graphQLSchema, keystone, configFileExists, projectAdminPath) => [...['next.config.js', 'tsconfig.json'].map(outputPath => ({
  mode: 'copy',
  inputPath: Path.join(pkgDir, 'static', outputPath),
  outputPath
})), {
  mode: 'write',
  outputPath: 'pages/no-access.js',
  src: noAccessTemplate(config.session)
}, {
  mode: 'write',
  outputPath: 'pages/_app.js',
  src: appTemplate(config, graphQLSchema, {
    configFileExists,
    projectAdminPath
  })
}, {
  mode: 'write',
  src: homeTemplate(keystone.lists),
  outputPath: 'pages/index.js'
}, ...Object.values(keystone.lists).map(({
  adminUILabels: {
    path
  },
  key
}) => ({
  mode: 'write',
  src: listTemplate(key),
  outputPath: `pages/${path}/index.js`
})), ...Object.values(keystone.lists).map(({
  adminUILabels: {
    path
  },
  key
}) => ({
  mode: 'write',
  src: itemTemplate(key),
  outputPath: `pages/${path}/[id].js`
}))];

exports.viewHash = viewHash;
exports.writeAdminFiles = writeAdminFiles;
