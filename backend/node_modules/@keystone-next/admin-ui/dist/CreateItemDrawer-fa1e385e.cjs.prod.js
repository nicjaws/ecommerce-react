'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var React = require('react');
var isDeepEqual = require('fast-deep-equal');
var core = require('@keystone-ui/core');
var modals = require('@keystone-ui/modals');
var toast = require('@keystone-ui/toast');
var loading = require('@keystone-ui/loading');
var client = require('@apollo/client');
var context_dist_adminUi = require('../context/dist/admin-ui.cjs.prod.js');
var GraphQLErrorNotice = require('./GraphQLErrorNotice-b55ab5a7.cjs.prod.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var isDeepEqual__default = /*#__PURE__*/_interopDefault(isDeepEqual);

function CreateItemDrawer({
  listKey,
  onClose,
  onCreate
}) {
  const {
    createViewFieldModes
  } = context_dist_adminUi.useKeystone();
  const list = context_dist_adminUi.useList(listKey);
  const toasts = toast.useToasts();
  const [createItem, {
    loading: loading$1,
    error
  }] = client.useMutation(client.gql`mutation($data: ${list.gqlNames.createInputName}!) {
      item: ${list.gqlNames.createMutationName}(data: $data) {
        id
        label: ${list.labelField}
    }
  }`);
  const [valuesByFieldPath, setValuesByFieldPath] = React.useState(() => {
    const value = {};
    Object.keys(list.fields).forEach(fieldPath => {
      value[fieldPath] = list.fields[fieldPath].controller.defaultValue;
    });
    return value;
  });
  const invalidFields = React.useMemo(() => {
    const invalidFields = new Set();
    Object.keys(valuesByFieldPath).forEach(fieldPath => {
      const val = valuesByFieldPath[fieldPath];
      const validateFn = list.fields[fieldPath].controller.validate;

      if (validateFn) {
        const result = validateFn(val);

        if (result === false) {
          invalidFields.add(fieldPath);
        }
      }
    });
    return invalidFields;
  }, [list, valuesByFieldPath]);
  const [forceValidation, setForceValidation] = React.useState(false);
  const fields = Object.keys(list.fields).filter(fieldPath => createViewFieldModes.state === 'loaded' ? createViewFieldModes.lists[listKey][fieldPath] !== 'hidden' : false).map((fieldPath, index) => {
    const field = list.fields[fieldPath];
    return core.jsx(field.views.Field, {
      key: fieldPath,
      field: field.controller,
      value: valuesByFieldPath[fieldPath],
      forceValidation: forceValidation && invalidFields.has(fieldPath),
      onChange: fieldValue => {
        setValuesByFieldPath(_objectSpread(_objectSpread({}, valuesByFieldPath), {}, {
          [fieldPath]: fieldValue
        }));
      },
      autoFocus: index === 0
    });
  });
  return core.jsx(modals.Drawer, {
    title: `Create ${list.singular}`,
    width: "wide",
    actions: {
      confirm: {
        label: `Create ${list.singular}`,
        loading: loading$1,
        action: () => {
          const newForceValidation = invalidFields.size !== 0;
          setForceValidation(newForceValidation);
          if (newForceValidation) return;
          const data = {};
          Object.keys(list.fields).forEach(fieldPath => {
            const {
              controller
            } = list.fields[fieldPath];
            const serialized = controller.serialize(valuesByFieldPath[fieldPath]);

            if (!isDeepEqual__default['default'](serialized, controller.serialize(controller.defaultValue))) {
              Object.assign(data, serialized);
            }
          });
          createItem({
            variables: {
              data
            }
          }).then(({
            data
          }) => {
            const label = data.item.label || data.item.id;
            onCreate({
              id: data.item.id,
              label
            });
            toasts.addToast({
              title: label,
              message: 'Created Successfully',
              tone: 'positive'
            });
          }).catch(() => {});
        }
      },
      cancel: {
        label: 'Cancel',
        action: onClose
      }
    }
  }, createViewFieldModes.state === 'error' && core.jsx(GraphQLErrorNotice.GraphQLErrorNotice, {
    networkError: createViewFieldModes.error instanceof Error ? createViewFieldModes.error : undefined,
    errors: createViewFieldModes.error instanceof Error ? undefined : createViewFieldModes.error
  }), createViewFieldModes.state === 'loading' && core.jsx(loading.LoadingDots, {
    label: "Loading create form"
  }), error && core.jsx(GraphQLErrorNotice.GraphQLErrorNotice, {
    networkError: error === null || error === void 0 ? void 0 : error.networkError,
    errors: error === null || error === void 0 ? void 0 : error.graphQLErrors
  }), core.jsx(core.Stack, {
    gap: "xlarge",
    paddingY: "xlarge"
  }, fields, fields.length === 0 && 'There are no fields that you can read or edit'));
}

exports.CreateItemDrawer = CreateItemDrawer;
