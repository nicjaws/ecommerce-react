import _extends from '@babel/runtime/helpers/esm/extends';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import { useMemo, Fragment, useState, useEffect } from 'react';
import { Button } from '@keystone-ui/button';
import { jsx, Box, Stack, VisuallyHidden, Heading, Divider, useTheme, Inline, Center } from '@keystone-ui/core';
import { Select, CheckboxControl } from '@keystone-ui/fields';
import { ArrowRightCircleIcon } from '@keystone-ui/icons/icons/ArrowRightCircleIcon';
import { LoadingDots } from '@keystone-ui/loading';
import { DrawerController, AlertDialog } from '@keystone-ui/modals';
import { useToasts } from '@keystone-ui/toast';
import { gql, useQuery, useMutation } from '@apollo/client';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import { C as CellLink } from '../../../dist/CellLink-dd890306.esm.js';
import '@babel/runtime/helpers/defineProperty';
import '@keystone-ui/icons/icons/AlertTriangleIcon';
import 'next/link';
import { useList } from '../../../context/dist/admin-ui.esm.js';
import { useRouter } from 'next/router';
import { Popover, usePopover, PopoverDialog } from '@keystone-ui/popover';
import '@keystone-ui/icons/icons/MoreHorizontalIcon';
import { ChevronRightIcon } from '@keystone-ui/icons/icons/ChevronRightIcon';
import '../../../dist/SignoutButton-be30cf42.esm.js';
import { Link } from '../../../router/dist/admin-ui.esm.js';
import { P as PageContainer, H as HEADER_HEIGHT } from '../../../dist/GraphQLErrorNotice-80fc36a5.esm.js';
import { C as CreateItemDrawer } from '../../../dist/CreateItemDrawer-44bc7d45.esm.js';
import '@keystone-ui/notice';
import { makeDataGetter, getRootGraphQLFieldsFromFieldController } from '@keystone-next/admin-ui-utils';
import { ChevronDownIcon } from '@keystone-ui/icons/icons/ChevronDownIcon';
import { Options, OptionPrimitive, CheckMark } from '@keystone-ui/options';
import { ChevronLeftIcon } from '@keystone-ui/icons/icons/ChevronLeftIcon';
import _toPropertyKey from '@babel/runtime/helpers/esm/toPropertyKey';
import { Pill } from '@keystone-ui/pill';
import '@emotion/hash';
import '@keystone-next/types';
import '../../../dist/admin-meta-graphql-c0552487.esm.js';
import 'apollo-upload-client';
import 'fast-deep-equal';

function useSelectedFields(list, fieldModesByFieldPath) {
  const {
    query
  } = useRouter();
  const selectedFieldsFromUrl = typeof query.fields === 'string' ? query.fields : '';
  return useMemo(() => {
    let selectedFieldsArray = selectedFieldsFromUrl ? selectedFieldsFromUrl.split(',') : list.initialColumns;
    let fields = selectedFieldsArray.filter(field => {
      return fieldModesByFieldPath[field] === 'read';
    });
    return new Set(fields.length === 0 ? [list.labelField] : fields);
  }, [list, selectedFieldsFromUrl, fieldModesByFieldPath]);
}

function isArrayEqual(arrA, arrB) {
  if (arrA.length !== arrB.length) return false;

  for (let i = 0; i < arrA.length; i++) {
    if (arrA[i] !== arrB[i]) {
      return false;
    }
  }

  return true;
}

const Option = props => {
  return jsx(OptionPrimitive, props, props.children, jsx(CheckMark, {
    isDisabled: props.isDisabled,
    isFocused: props.isFocused,
    isSelected: props.isSelected
  }));
};

const fieldSelectionOptionsComponents = {
  Option
};
function FieldSelection({
  list,
  fieldModesByFieldPath
}) {
  const router = useRouter();
  const selectedFields = useSelectedFields(list, fieldModesByFieldPath);

  const setNewSelectedFields = selectedFields => {
    if (isArrayEqual(selectedFields, list.initialColumns)) {
      const _router$query = router.query,
            otherQueryFields = _objectWithoutProperties(_router$query, ["fields"]);

      router.push({
        query: otherQueryFields
      });
    } else {
      router.push({
        query: _objectSpread(_objectSpread({}, router.query), {}, {
          fields: selectedFields.join(',')
        })
      });
    }
  };

  const fields = [];
  Object.keys(fieldModesByFieldPath).forEach(fieldPath => {
    if (fieldModesByFieldPath[fieldPath] === 'read') {
      fields.push({
        value: fieldPath,
        label: list.fields[fieldPath].label,
        isDisabled: selectedFields.size === 1 && selectedFields.has(fieldPath)
      });
    }
  });
  return jsx(Popover, {
    triggerRenderer: ({
      triggerProps
    }) => {
      return jsx(Button, _extends({
        weight: "link",
        css: {
          padding: 4
        }
      }, triggerProps), jsx("span", {
        css: {
          display: 'inline-flex',
          justifyContent: 'center',
          alignItems: 'center'
        }
      }, selectedFields.size, " column", selectedFields.size === 1 ? '' : 's', ' ', jsx(ChevronDownIcon, {
        size: "smallish"
      })));
    }
  }, jsx("div", {
    css: {
      width: 320
    }
  }, jsx(Box, {
    padding: "medium"
  }, jsx(Options, {
    onChange: options => {
      if (!Array.isArray(options)) return;
      setNewSelectedFields(options.map(x => x.value));
    },
    isMulti: true,
    value: fields.filter(option => {
      return selectedFields.has(option.value);
    }),
    options: fields,
    components: fieldSelectionOptionsComponents
  }))));
}

const fieldSelectComponents = {
  Option: (_ref) => {
    let {
      children
    } = _ref,
        props = _objectWithoutProperties(_ref, ["children"]);

    let theme = useTheme();
    let iconColor = props.isFocused ? theme.colors.foreground : theme.colors.foregroundDim;
    return jsx(OptionPrimitive, props, jsx("span", null, children), jsx("div", {
      css: {
        alignItems: 'center',
        display: 'flex',
        height: 24,
        justifyContent: 'center',
        width: 24
      }
    }, jsx(ChevronRightIcon, {
      css: {
        color: iconColor
      }
    })));
  }
};
function FilterAdd({
  listKey
}) {
  const {
    isOpen,
    setOpen,
    trigger,
    dialog,
    arrow
  } = usePopover({
    placement: 'bottom',
    modifiers: [{
      name: 'offset',
      options: {
        offset: [0, 8]
      }
    }]
  });
  return jsx(Fragment, null, jsx(Button, _extends({
    tone: "active",
    size: "small"
  }, trigger.props, {
    ref: trigger.ref,
    onClick: () => setOpen(true)
  }), jsx(Box, {
    as: "span",
    marginRight: "xsmall"
  }, "Filter List"), jsx(ChevronDownIcon, {
    size: "small"
  })), jsx(PopoverDialog, _extends({
    arrow: arrow,
    isVisible: isOpen
  }, dialog.props, {
    ref: dialog.ref
  }), isOpen && jsx(FilterAddPopoverContent, {
    onClose: () => {
      setOpen(false);
    },
    listKey: listKey
  })));
}

function FilterAddPopoverContent({
  onClose,
  listKey
}) {
  const list = useList(listKey);
  const router = useRouter();
  const fieldsWithFilters = useMemo(() => {
    const fieldsWithFilters = {};
    Object.keys(list.fields).forEach(fieldPath => {
      const field = list.fields[fieldPath];

      if (field.controller.filter) {
        // TODO: make all the things readonly so this works
        fieldsWithFilters[fieldPath] = field;
      }
    });
    return fieldsWithFilters;
  }, [list.fields]);
  const filtersByFieldThenType = useMemo(() => {
    const filtersByFieldThenType = {};
    Object.keys(fieldsWithFilters).forEach(fieldPath => {
      const field = fieldsWithFilters[fieldPath];
      let hasUnusedFilters = false;
      const filters = {};
      Object.keys(field.controller.filter.types).forEach(filterType => {
        if (router.query[`!${fieldPath}_${filterType}`] === undefined) {
          hasUnusedFilters = true;
          filters[filterType] = field.controller.filter.types[filterType].label;
        }
      });

      if (hasUnusedFilters) {
        filtersByFieldThenType[fieldPath] = filters;
      }
    });
    return filtersByFieldThenType;
  }, [router.query, fieldsWithFilters]);
  const [state, setState] = useState({
    kind: 'selecting-field'
  });
  return jsx(Stack, {
    padding: "medium",
    as: "form",
    css: {
      minWidth: 320
    },
    onSubmit: event => {
      event.preventDefault();

      if (state.kind === 'filter-value') {
        router.push({
          query: _objectSpread(_objectSpread({}, router.query), {}, {
            [`!${state.fieldPath}_${state.filterType}`]: JSON.stringify(state.filterValue)
          })
        });
        onClose();
      }
    },
    gap: "small"
  }, jsx("div", {
    css: {
      position: 'relative'
    }
  }, state.kind !== 'selecting-field' && jsx("button", {
    onClick: () => {
      setState({
        kind: 'selecting-field'
      });
    },
    css: {
      border: 0,
      background: 'transparent',
      cursor: 'pointer',
      position: 'absolute'
    }
  }, jsx(VisuallyHidden, null, "Back"), jsx(ChevronLeftIcon, {
    size: "smallish"
  })), jsx(Heading, {
    textAlign: "center",
    type: "h5"
  }, (() => {
    switch (state.kind) {
      case 'selecting-field':
        {
          return 'Filter';
        }

      case 'filter-value':
        {
          return list.fields[state.fieldPath].label;
        }
    }
  })())), jsx(Divider, null), state.kind === 'selecting-field' && jsx(Options, {
    components: fieldSelectComponents,
    onChange: newVal => {
      const fieldPath = newVal.value;
      const filterType = Object.keys(filtersByFieldThenType[fieldPath])[0];
      setState({
        kind: 'filter-value',
        fieldPath,
        filterType,
        filterValue: fieldsWithFilters[fieldPath].controller.filter.types[filterType].initialValue
      });
    },
    options: Object.keys(filtersByFieldThenType).map(fieldPath => ({
      label: fieldsWithFilters[fieldPath].label,
      value: fieldPath
    }))
  }), state.kind === 'filter-value' && jsx(Select, {
    width: "full",
    value: {
      value: state.filterType,
      label: filtersByFieldThenType[state.fieldPath][state.filterType]
    },
    onChange: newVal => {
      if (newVal) {
        setState({
          kind: 'filter-value',
          fieldPath: state.fieldPath,
          filterValue: fieldsWithFilters[state.fieldPath].controller.filter.types[newVal.value].initialValue,
          filterType: newVal.value
        });
      }
    },
    options: Object.keys(filtersByFieldThenType[state.fieldPath]).map(filterType => ({
      label: filtersByFieldThenType[state.fieldPath][filterType],
      value: filterType
    }))
  }), state.kind == 'filter-value' && (() => {
    const {
      Filter
    } = fieldsWithFilters[state.fieldPath].controller.filter;
    return jsx(Filter, {
      type: state.filterType,
      value: state.filterValue,
      onChange: value => {
        setState(state => _objectSpread(_objectSpread({}, state), {}, {
          filterValue: value
        }));
      }
    });
  })(), state.kind == 'filter-value' && jsx("div", {
    css: {
      display: 'flex',
      justifyContent: 'space-between'
    }
  }, jsx(Button, {
    onClick: onClose
  }, "Cancel"), jsx(Button, {
    type: "submit"
  }, "Apply")));
}

function FilterList({
  filters,
  list
}) {
  return jsx(Inline, {
    gap: "small"
  }, filters.map(filter => {
    const field = list.fields[filter.field];
    return jsx(FilterPill, {
      key: `${filter.field}_${filter.type}`,
      field: field,
      filter: filter
    });
  }));
}

function FilterPill({
  filter,
  field
}) {
  const router = useRouter();
  const {
    isOpen,
    setOpen,
    trigger,
    dialog,
    arrow
  } = usePopover({
    placement: 'bottom',
    modifiers: [{
      name: 'offset',
      options: {
        offset: [0, 8]
      }
    }]
  }); // doing this because returning a string from Label will be VERY common
  // but https://github.com/microsoft/TypeScript/issues/21699 isn't resolved yet

  const Label = field.controller.filter.Label;
  return jsx(Fragment, null, jsx(Pill, _extends({
    onClick: () => {
      setOpen(true);
    }
  }, trigger.props, {
    ref: trigger.ref,
    weight: "light",
    tone: "passive",
    onRemove: () => {
      const _router$query = router.query,
            _ref = `!${filter.field}_${filter.type}`,
            queryToKeep = _objectWithoutProperties(_router$query, [_ref].map(_toPropertyKey));

      router.push({
        query: queryToKeep
      });
    }
  }), field.label, ' ', jsx(Label, {
    label: field.controller.filter.types[filter.type].label,
    type: filter.type,
    value: filter.value
  })), jsx(PopoverDialog, _extends({
    arrow: arrow
  }, dialog.props, {
    ref: dialog.ref,
    isVisible: isOpen
  }), jsx(EditDialog, {
    onClose: () => {
      setOpen(false);
    },
    field: field,
    filter: filter
  })));
}

function EditDialog({
  filter,
  field,
  onClose
}) {
  const Filter = field.controller.filter.Filter;
  const router = useRouter();
  const [value, setValue] = useState(filter.value);
  return jsx(Stack, {
    as: "form",
    padding: "small",
    gap: "small",
    onSubmit: event => {
      event.preventDefault();
      router.push({
        query: _objectSpread(_objectSpread({}, router.query), {}, {
          [`!${filter.field}_${filter.type}`]: JSON.stringify(value)
        })
      });
      onClose();
    }
  }, jsx(Filter, {
    autoFocus: true,
    type: filter.type,
    value: value,
    onChange: setValue
  }), jsx("div", {
    css: {
      display: 'flex',
      justifyContent: 'space-between'
    }
  }, jsx(Button, {
    onClick: onClose
  }, "Cancel"), jsx(Button, {
    type: "submit"
  }, "Save")));
}

function Page({
  page,
  currentPage
}) {
  const {
    query
  } = useRouter();

  const newQuery = _objectSpread(_objectSpread({}, query), {}, {
    page: page
  });

  if (page === 1) {
    delete newQuery.page;
  }

  return jsx(Link, {
    css: {
      textDecoration: currentPage === page ? 'none' : undefined,
      color: currentPage === page ? 'inherit' : undefined
    },
    href: {
      query: newQuery
    }
  }, page);
}

function Pagination({
  currentPage,
  total,
  pageSize,
  listKey
}) {
  const list = useList(listKey);
  if (total <= pageSize) return null;
  const pages = [];
  const totalPages = Math.ceil(total / pageSize);
  let minPage = 1;
  let maxPage = totalPages;
  const limit = 5;

  if (limit < totalPages) {
    const rightLimit = Math.floor(limit / 2);
    const leftLimit = rightLimit + limit % 2 - 1;
    minPage = currentPage - leftLimit;
    maxPage = currentPage + rightLimit;

    if (minPage < 1) {
      maxPage = limit;
      minPage = 1;
    }

    if (maxPage > totalPages) {
      minPage = totalPages - limit + 1;
      maxPage = totalPages;
    }
  }

  if (minPage > 1) {
    pages.push(jsx(Page, {
      key: "page_start",
      currentPage: currentPage,
      page: 1
    }));
  }

  for (let page = minPage; page <= maxPage; page++) {
    pages.push(jsx(Page, {
      key: page,
      page: page,
      currentPage: currentPage
    }));
  } // go to last


  if (maxPage < totalPages) {
    pages.push(jsx(Page, {
      key: "page_end",
      page: totalPages,
      currentPage: currentPage
    }));
  }

  return jsx(Center, null, jsx(Stack, {
    across: true,
    gap: "small"
  }, pages), jsx(PaginationLabel, {
    currentPage: currentPage,
    pageSize: pageSize,
    plural: list.plural,
    singular: list.singular,
    total: total
  }));
}
function PaginationLabel({
  currentPage,
  pageSize,
  plural,
  singular,
  total
}) {
  if (!total) {
    return jsx("span", null, "No ", plural);
  }

  let count = '';
  const start = pageSize * (currentPage - 1) + 1;
  const end = Math.min(start + pageSize - 1, total);

  if (total > pageSize) {
    count = `${start} to ${end} of ${total} ${plural}`;
  } else {
    count = `${total} `;

    if (total > 1 && plural) {
      count += plural;
    } else if (total === 1 && singular) {
      count += singular;
    }
  }

  return jsx("span", null, "Showing ", jsx("strong", null, count));
}

function useSort(list) {
  const {
    query
  } = useRouter();
  let sortByFromUrl = typeof query.sortBy === 'string' ? query.sortBy : '';
  return useMemo(() => {
    if (sortByFromUrl === '') return list.initialSort;
    let direction = 'ASC';
    let sortByField = sortByFromUrl;

    if (sortByFromUrl.charAt(0) === '-') {
      sortByField = sortByFromUrl.substr(1);
      direction = 'DESC';
    }

    if (!list.fields[sortByField].isOrderable) return null;
    return {
      field: sortByField,
      direction
    };
  }, [sortByFromUrl, list]);
}

function SortSelection({
  list
}) {
  const sort = useSort(list);
  const {
    isOpen,
    setOpen,
    trigger,
    dialog,
    arrow
  } = usePopover({
    placement: 'bottom',
    modifiers: [{
      name: 'offset',
      options: {
        offset: [0, 8]
      }
    }]
  });
  return jsx(Fragment, null, jsx(Button, _extends({}, trigger.props, {
    weight: "link",
    css: {
      padding: 4
    },
    ref: trigger.ref,
    onClick: () => setOpen(true)
  }), jsx("span", {
    css: {
      display: 'inline-flex',
      justifyContent: 'center',
      alignItems: 'center'
    }
  }, sort ? `${list.fields[sort.field].label} ${{
    ASC: 'ascending',
    DESC: 'descending'
  }[sort.direction]}` : 'No field', jsx(ChevronDownIcon, {
    size: "smallish"
  }))), jsx(PopoverDialog, _extends({
    arrow: arrow,
    isVisible: isOpen
  }, dialog.props, {
    ref: dialog.ref
  }), isOpen && jsx(SortSelectionPopoverContent, {
    onClose: () => {
      setOpen(false);
    },
    list: list
  })));
}
const noFieldOption = {
  label: 'No field',
  value: '___________NO_FIELD___________'
};

function SortSelectionPopoverContent({
  onClose,
  list
}) {
  const sort = useSort(list);
  const router = useRouter();
  return jsx(Stack, {
    padding: "medium",
    css: {
      minWidth: 320
    },
    gap: "small"
  }, jsx("div", {
    css: {
      position: 'relative'
    }
  }, jsx(Heading, {
    textAlign: "center",
    type: "h5"
  }, "Sort")), jsx(Divider, null), jsx(Options, {
    value: sort ? {
      label: list.fields[sort.field].label,
      value: sort.field
    } : noFieldOption,
    components: fieldSelectionOptionsComponents,
    onChange: newVal => {
      const fieldPath = newVal.value;

      if (fieldPath === noFieldOption.value) {
        const _router$query = router.query,
              restOfQuery = _objectWithoutProperties(_router$query, ["sortBy"]);

        router.push({
          query: restOfQuery
        });
      } else {
        router.push({
          query: _objectSpread(_objectSpread({}, router.query), {}, {
            sortBy: (sort === null || sort === void 0 ? void 0 : sort.field) === fieldPath && sort.direction === 'ASC' ? `-${sort.field}` : fieldPath
          })
        });
      }

      onClose();
    },
    options: Object.keys(list.fields).filter(fieldPath => list.fields[fieldPath].isOrderable).map(fieldPath => ({
      label: list.fields[fieldPath].label,
      value: fieldPath
    })).concat(noFieldOption)
  }));
}

function useFilters(list) {
  const {
    query
  } = useRouter();
  const possibleFilters = useMemo(() => {
    const possibleFilters = {};
    Object.entries(list.fields).forEach(([fieldPath, field]) => {
      if (field.controller.filter) {
        Object.keys(field.controller.filter.types).forEach(type => {
          possibleFilters[`!${fieldPath}_${type}`] = {
            type,
            field: fieldPath
          };
        });
      }
    });
    return possibleFilters;
  }, [list]);
  const filters = useMemo(() => {
    let filters = [];
    Object.keys(query).forEach(key => {
      const filter = possibleFilters[key];
      const val = query[key];

      if (filter && typeof val === 'string') {
        let value;

        try {
          value = JSON.parse(val);
        } catch (err) {}

        if (val !== undefined) {
          filters.push(_objectSpread(_objectSpread({}, filter), {}, {
            value
          }));
        }
      }
    });
    let where = {};
    filters.forEach(filter => {
      Object.assign(where, list.fields[filter.field].controller.filter.graphql({
        type: filter.type,
        value: filter.value
      }));
    });
    return {
      filters,
      where
    };
  }, [query, possibleFilters, list]);
  return filters;
}

let listMetaGraphqlQuery = gql`
  query($listKey: String!) {
    keystone {
      adminMeta {
        list(key: $listKey) {
          hideDelete
          hideCreate
          fields {
            path
            listView {
              fieldMode
            }
          }
        }
      }
    }
  }
`;

function useQueryParamsFromLocalStorage(listKey) {
  const router = useRouter();
  const localStorageKey = `keystone.list.${listKey}.list.page.info`;
  useEffect(() => {
    let hasSomeQueryParamsWhichAreAboutListPage = Object.keys(router.query).some(x => x.startsWith('!') || x === 'page' || x === 'pageSize' || x === 'fields');

    if (!hasSomeQueryParamsWhichAreAboutListPage) {
      const queryParamsFromLocalStorage = localStorage.getItem(localStorageKey);
      let parsed;

      try {
        parsed = JSON.parse(queryParamsFromLocalStorage);
      } catch (err) {}

      if (parsed) {
        router.replace({
          query: _objectSpread(_objectSpread({}, router.query), parsed)
        });
      }
    }
  }, [localStorageKey]);
  useEffect(() => {
    let queryParamsToSerialize = {};
    Object.keys(router.query).forEach(key => {
      if (key.startsWith('!') || key === 'page' || key === 'pageSize' || key === 'fields') {
        queryParamsToSerialize[key] = router.query[key];
      }
    });

    if (Object.keys(queryParamsToSerialize).length) {
      localStorage.setItem(`keystone.list.${listKey}.list.page.info`, JSON.stringify(queryParamsToSerialize));
    } else {
      localStorage.removeItem(`keystone.list.${listKey}.list.page.info`);
    }
  }, [localStorageKey, router]);
}

const ListPage = ({
  listKey
}) => {
  var _metaQuery$data2, _metaQuery$data2$keys, _metaQuery$data$keyst2, _metaQuery$data3, _metaQuery$data3$keys;

  const list = useList(listKey);
  const {
    query
  } = useRouter();
  useQueryParamsFromLocalStorage(listKey);
  let currentPage = typeof query.page === 'string' && !Number.isNaN(parseInt(query.page)) ? Number(query.page) : 1;
  let pageSize = typeof query.pageSize === 'string' && !Number.isNaN(parseInt(query.pageSize)) ? parseInt(query.pageSize) : list.pageSize;
  const sort = useSort(list);
  const filters = useFilters(list);
  let metaQuery = useQuery(listMetaGraphqlQuery, {
    variables: {
      listKey
    }
  });
  let listViewFieldModesByField = useMemo(() => {
    var _metaQuery$data, _metaQuery$data$keyst;

    let listViewFieldModesByField = {};
    (_metaQuery$data = metaQuery.data) === null || _metaQuery$data === void 0 ? void 0 : (_metaQuery$data$keyst = _metaQuery$data.keystone.adminMeta.list) === null || _metaQuery$data$keyst === void 0 ? void 0 : _metaQuery$data$keyst.fields.forEach(field => {
      listViewFieldModesByField[field.path] = field.listView.fieldMode;
    });
    return listViewFieldModesByField;
  }, [(_metaQuery$data2 = metaQuery.data) === null || _metaQuery$data2 === void 0 ? void 0 : (_metaQuery$data2$keys = _metaQuery$data2.keystone.adminMeta.list) === null || _metaQuery$data2$keys === void 0 ? void 0 : _metaQuery$data2$keys.fields]);
  let selectedFields = useSelectedFields(list, listViewFieldModesByField);
  let {
    data: newData,
    error: newError,
    refetch,
    loading
  } = useQuery(useMemo(() => {
    let selectedGqlFields = [...selectedFields].map(fieldPath => {
      return list.fields[fieldPath].controller.graphqlSelection;
    }).join('\n');
    return gql`
      query ($where: ${list.gqlNames.whereInputName}, $first: Int!, $skip: Int!, $sortBy: [${list.gqlNames.listSortName}!]) {
        items: ${list.gqlNames.listQueryName}(where: $where,first: $first, skip: $skip, sortBy: $sortBy) {
          ${// TODO: maybe namespace all the fields instead of doing this
    selectedFields.has('id') ? '' : 'id'}
          ${selectedGqlFields}
        }
        meta: ${list.gqlNames.listQueryMetaName}(where: $where) {
          count
        }
      }
    `;
  }, [list, selectedFields]), {
    fetchPolicy: 'cache-and-network',
    errorPolicy: 'all',
    variables: {
      where: filters.where,
      first: pageSize,
      skip: (currentPage - 1) * pageSize,
      sortBy: sort ? [`${sort.field}_${sort.direction}`] : undefined
    }
  });
  let [dataState, setDataState] = useState({
    data: newData,
    error: newError
  });

  if (newData && dataState.data !== newData) {
    setDataState({
      data: newData,
      error: newError
    });
  }

  const {
    data,
    error
  } = dataState;
  const dataGetter = makeDataGetter(data, error === null || error === void 0 ? void 0 : error.graphQLErrors);
  const [selectedItemsState, setSelectedItems] = useState(() => ({
    itemsFromServer: undefined,
    selectedItems: new Set()
  })); // this removes the selected items which no longer exist when the data changes
  // because someone goes to another page, changes filters or etc.

  if (data && data.items && selectedItemsState.itemsFromServer !== data.items) {
    const newSelectedItems = new Set();
    data.items.forEach(item => {
      if (selectedItemsState.selectedItems.has(item.id)) {
        newSelectedItems.add(item.id);
      }
    });
    setSelectedItems({
      itemsFromServer: data.items,
      selectedItems: newSelectedItems
    });
  }

  const theme = useTheme();
  const showCreate = !((_metaQuery$data$keyst2 = (_metaQuery$data3 = metaQuery.data) === null || _metaQuery$data3 === void 0 ? void 0 : (_metaQuery$data3$keys = _metaQuery$data3.keystone.adminMeta.list) === null || _metaQuery$data3$keys === void 0 ? void 0 : _metaQuery$data3$keys.hideCreate) !== null && _metaQuery$data$keyst2 !== void 0 ? _metaQuery$data$keyst2 : true) || null;
  return jsx(PageContainer, {
    header: jsx(ListPageHeader, {
      listKey: listKey
    })
  }, metaQuery.error ? // TODO: Show errors nicely and with information
  'Error...' : data && metaQuery.data ? jsx(Fragment, null, jsx(Stack, {
    across: true,
    gap: "medium",
    align: "center",
    marginTop: "xlarge"
  }, showCreate && jsx(CreateButton, {
    listKey: listKey
  }), data.meta.count || filters.filters.length ? jsx(FilterAdd, {
    listKey: listKey
  }) : null, filters.filters.length ? jsx(FilterList, {
    filters: filters.filters,
    list: list
  }) : null), data.meta.count ? jsx(Fragment, null, jsx(ResultsSummaryContainer, null, (() => {
    const selectedItems = selectedItemsState.selectedItems;
    const selectedItemsCount = selectedItems.size;

    if (selectedItemsCount) {
      var _metaQuery$data$keyst3, _metaQuery$data4, _metaQuery$data4$keys;

      return jsx(Fragment, null, jsx("span", {
        css: {
          marginRight: theme.spacing.small
        }
      }, "Selected ", selectedItemsCount, " of ", data.items.length), !((_metaQuery$data$keyst3 = (_metaQuery$data4 = metaQuery.data) === null || _metaQuery$data4 === void 0 ? void 0 : (_metaQuery$data4$keys = _metaQuery$data4.keystone.adminMeta.list) === null || _metaQuery$data4$keys === void 0 ? void 0 : _metaQuery$data4$keys.hideDelete) !== null && _metaQuery$data$keyst3 !== void 0 ? _metaQuery$data$keyst3 : true) && jsx(DeleteManyButton, {
        list: list,
        selectedItems: selectedItems,
        refetch: refetch
      }));
    }

    return jsx(Fragment, null, jsx(PaginationLabel, {
      currentPage: currentPage,
      pageSize: pageSize,
      plural: list.plural,
      singular: list.singular,
      total: data.meta.count
    }), ", sorted by ", jsx(SortSelection, {
      list: list
    }), "with", ' ', jsx(FieldSelection, {
      list: list,
      fieldModesByFieldPath: listViewFieldModesByField
    }), ' ', loading && jsx(LoadingDots, {
      label: "Loading item data",
      size: "small",
      tone: "active"
    }));
  })()), jsx(ListTable, {
    count: data.meta.count,
    currentPage: currentPage,
    itemsGetter: dataGetter.get('items'),
    listKey: listKey,
    pageSize: pageSize,
    selectedFields: selectedFields,
    sort: sort,
    selectedItems: selectedItemsState.selectedItems,
    onSelectedItemsChange: selectedItems => {
      setSelectedItems({
        itemsFromServer: selectedItemsState.itemsFromServer,
        selectedItems
      });
    }
  })) : jsx(ResultsSummaryContainer, null, "No ", list.plural, " found.")) : jsx(Center, {
    css: {
      height: `calc(100vh - ${HEADER_HEIGHT}px)`
    }
  }, jsx(LoadingDots, {
    label: "Loading item data",
    size: "large",
    tone: "passive"
  })));
};

const CreateButton = ({
  listKey
}) => {
  const list = useList(listKey);
  const router = useRouter();
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
  return jsx(Fragment, null, jsx(Button, {
    disabled: isCreateModalOpen,
    onClick: () => {
      setIsCreateModalOpen(true);
    },
    tone: "active",
    size: "small",
    weight: "bold"
  }, "Create ", list.singular), jsx(DrawerController, {
    isOpen: isCreateModalOpen
  }, jsx(CreateItemDrawer, {
    listKey: listKey,
    onCreate: ({
      id
    }) => {
      router.push(`/${list.path}/[id]`, `/${list.path}/${id}`);
    },
    onClose: () => {
      setIsCreateModalOpen(false);
    }
  })));
};

const ListPageHeader = ({
  listKey
}) => {
  const list = useList(listKey);
  return jsx(Fragment, null, jsx("div", {
    css: {
      alignItems: 'center',
      display: 'flex',
      flex: 1,
      justifyContent: 'space-between'
    }
  }, jsx(Heading, {
    type: "h3"
  }, list.label)));
};

const ResultsSummaryContainer = ({
  children
}) => jsx("p", {
  css: {
    // TODO: don't do this
    // (this is to make it so things don't move when a user selects an item)
    minHeight: 38,
    display: 'flex',
    alignItems: 'center'
  }
}, children);

const SortDirectionArrow = ({
  direction
}) => {
  const size = '0.25em';
  return jsx("span", {
    css: {
      borderLeft: `${size} solid transparent`,
      borderRight: `${size} solid transparent`,
      borderTop: `${size} solid`,
      display: 'inline-block',
      height: 0,
      marginLeft: '0.33em',
      marginTop: '-0.125em',
      verticalAlign: 'middle',
      width: 0,
      transform: `rotate(${direction === 'DESC' ? '0deg' : '180deg'})`
    }
  });
};

function DeleteManyButton({
  selectedItems,
  list,
  refetch
}) {
  const [deleteItems, deleteItemsState] = useMutation(useMemo(() => gql`
  mutation($ids: [ID!]!) {
    ${list.gqlNames.deleteManyMutationName}(ids: $ids) {
      id
    }
  }
`, [list, selectedItems]));
  const [isOpen, setIsOpen] = useState(false);
  const toasts = useToasts();
  return jsx(Fragment, null, jsx(Button, {
    isLoading: deleteItemsState.loading,
    tone: "negative",
    onClick: async () => {
      setIsOpen(true);
    }
  }, "Delete"), jsx(AlertDialog // TODO: change the copy in the title and body of the modal
  , {
    isOpen: isOpen,
    title: "Delete Confirmation",
    tone: "negative",
    actions: {
      confirm: {
        label: 'Delete',
        action: async () => {
          await deleteItems({
            variables: {
              ids: [...selectedItems]
            }
          }).catch(err => {
            toasts.addToast({
              title: 'Failed to delete items',
              message: err.message,
              tone: 'negative'
            });
          });
          toasts.addToast({
            title: 'Deleted items successfully',
            tone: 'positive'
          });
          refetch();
        }
      },
      cancel: {
        label: 'Cancel',
        action: () => {
          setIsOpen(false);
        }
      }
    }
  }, "Are you sure you want to delete ", selectedItems.size, ' ', selectedItems.size === 1 ? list.singular : list.plural, "?"));
}

function ListTable({
  selectedFields,
  listKey,
  itemsGetter,
  count,
  sort,
  currentPage,
  pageSize,
  selectedItems,
  onSelectedItemsChange
}) {
  var _itemsGetter$data, _itemsGetter$data4;

  const list = useList(listKey);
  const {
    query
  } = useRouter();
  const shouldShowLinkIcon = !list.fields[selectedFields.keys().next().value].views.Cell.supportsLinkTo;
  return jsx(Box, {
    paddingBottom: "xlarge"
  }, jsx(TableContainer, null, jsx("colgroup", null, jsx("col", {
    width: "30"
  }), shouldShowLinkIcon && jsx("col", {
    width: "30"
  }), [...selectedFields].map(path => jsx("col", {
    key: path
  }))), jsx(TableHeaderRow, null, jsx(TableHeaderCell, {
    css: {
      paddingLeft: 0
    }
  }, jsx("label", {
    css: {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'start',
      cursor: 'pointer'
    }
  }, jsx(CheckboxControl, {
    size: "small",
    checked: selectedItems.size === ((_itemsGetter$data = itemsGetter.data) === null || _itemsGetter$data === void 0 ? void 0 : _itemsGetter$data.length),
    css: {
      cursor: 'default'
    },
    onChange: () => {
      var _itemsGetter$data2;

      const newSelectedItems = new Set();

      if (selectedItems.size !== ((_itemsGetter$data2 = itemsGetter.data) === null || _itemsGetter$data2 === void 0 ? void 0 : _itemsGetter$data2.length)) {
        var _itemsGetter$data3;

        (_itemsGetter$data3 = itemsGetter.data) === null || _itemsGetter$data3 === void 0 ? void 0 : _itemsGetter$data3.forEach(item => {
          if (item !== null && item.id !== null) {
            newSelectedItems.add(item.id);
          }
        });
      }

      onSelectedItemsChange(newSelectedItems);
    }
  }))), shouldShowLinkIcon && jsx(TableHeaderCell, null), [...selectedFields].map(path => {
    const label = list.fields[path].label;

    if (!list.fields[path].isOrderable) {
      return jsx(TableHeaderCell, {
        key: path
      }, label);
    }

    return jsx(TableHeaderCell, {
      key: path
    }, jsx(Link, {
      css: {
        display: 'block',
        textDecoration: 'none',
        color: 'inherit',
        ':hover': {
          color: 'inherit'
        }
      },
      href: {
        query: _objectSpread(_objectSpread({}, query), {}, {
          sortBy: (sort === null || sort === void 0 ? void 0 : sort.field) === path && sort.direction === 'ASC' ? `-${path}` : path
        })
      }
    }, label, (sort === null || sort === void 0 ? void 0 : sort.field) === path && jsx(SortDirectionArrow, {
      direction: sort.direction
    })));
  })), jsx("tbody", null, ((_itemsGetter$data4 = itemsGetter.data) !== null && _itemsGetter$data4 !== void 0 ? _itemsGetter$data4 : []).map((_, index) => {
    const itemGetter = itemsGetter.get(index);

    if (itemGetter.data === null || itemGetter.data.id === null) {
      if (itemGetter.errors) {
        return jsx("tr", {
          css: {
            color: 'red'
          },
          key: `index:${index}`
        }, itemGetter.errors[0].message);
      }

      return null;
    }

    const itemId = itemGetter.data.id;
    return jsx("tr", {
      key: itemId || `index:${index}`
    }, jsx(TableBodyCell, null, jsx("label", {
      css: {
        display: 'flex',
        minHeight: 38,
        alignItems: 'center',
        justifyContent: 'start' // cursor: 'pointer',

      }
    }, jsx(CheckboxControl, {
      size: "small",
      checked: selectedItems.has(itemId),
      css: {
        cursor: 'default'
      },
      onChange: () => {
        const newSelectedItems = new Set(selectedItems);

        if (selectedItems.has(itemId)) {
          newSelectedItems.delete(itemId);
        } else {
          newSelectedItems.add(itemId);
        }

        onSelectedItemsChange(newSelectedItems);
      }
    }))), shouldShowLinkIcon && jsx(TableBodyCell, null, jsx(Link, {
      css: {
        textDecoration: 'none',
        minHeight: 38,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      },
      href: `/${list.path}/[id]`,
      as: `/${list.path}/${encodeURIComponent(itemId)}`
    }, jsx(ArrowRightCircleIcon, {
      size: "smallish",
      "aria-label": "Go to item"
    }))), [...selectedFields].map((path, i) => {
      const field = list.fields[path];
      let {
        Cell
      } = list.fields[path].views;
      const itemForField = {};

      for (const graphqlField of getRootGraphQLFieldsFromFieldController(field.controller)) {
        const fieldGetter = itemGetter.get(graphqlField);

        if (fieldGetter.errors) {
          const errorMessage = fieldGetter.errors[0].message;
          return jsx(TableBodyCell, {
            css: {
              color: 'red'
            },
            key: path
          }, i === 0 && Cell.supportsLinkTo ? jsx(CellLink, {
            href: `/${list.path}/[id]`,
            as: `/${list.path}/${encodeURIComponent(itemId)}`
          }, errorMessage) : errorMessage);
        }

        itemForField[graphqlField] = fieldGetter.data;
      }

      return jsx(TableBodyCell, {
        key: path
      }, jsx(Cell, {
        field: field.controller,
        item: itemForField,
        linkTo: i === 0 && Cell.supportsLinkTo ? {
          href: `/${list.path}/[id]`,
          as: `/${list.path}/${encodeURIComponent(itemId)}`
        } : undefined
      }));
    }));
  }))), jsx(Pagination, {
    listKey: listKey,
    total: count,
    currentPage: currentPage,
    pageSize: pageSize
  }));
}

const TableContainer = ({
  children
}) => {
  return jsx("table", {
    css: {
      minWidth: '100%',
      tableLayout: 'fixed',
      'tr:last-child td': {
        borderBottomWidth: 0
      }
    },
    cellPadding: "0",
    cellSpacing: "0"
  }, children);
};

const TableHeaderRow = ({
  children
}) => {
  return jsx("thead", null, jsx("tr", null, children));
};

const TableHeaderCell = props => {
  const {
    colors,
    spacing,
    typography
  } = useTheme();
  return jsx("th", _extends({
    css: {
      backgroundColor: colors.background,
      borderBottom: `2px solid ${colors.border}`,
      color: colors.foregroundDim,
      fontSize: typography.fontSize.medium,
      fontWeight: typography.fontWeight.medium,
      padding: spacing.small,
      textAlign: 'left',
      position: 'sticky',
      top: 0
    }
  }, props));
};

const TableBodyCell = props => {
  const {
    colors,
    typography
  } = useTheme();
  return jsx("td", _extends({
    css: {
      borderBottom: `1px solid ${colors.border}`,
      fontSize: typography.fontSize.medium
    }
  }, props));
};

export { ListPage };
