import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import url from 'url';
import { mergeSchemas } from '@graphql-tools/merge';
import { password, timestamp } from '@keystone-next/fields';
import { randomBytes } from 'crypto';

async function findMatchingIdentity(identityField, identity, itemAPI) {
  const items = await itemAPI.findMany({
    where: {
      [identityField]: identity
    },
    resolveFields: false
  }); // Identity failures with helpful errors

  let code;

  if (items.length === 0) {
    code = 'IDENTITY_NOT_FOUND';
  } else if (items.length > 1) {
    code = 'MULTIPLE_IDENTITY_MATCHES';
  }

  if (code) {
    return {
      success: false,
      code
    };
  } else {
    return {
      success: true,
      item: items[0]
    };
  }
}

async function validateSecret(list, identityField, identity, secretField, protectIdentities, secret, itemAPI) {
  const match = await findMatchingIdentity(identityField, identity, itemAPI); // Identity failures with helpful errors

  let code;

  if (!match.success) {
    code = match.code;
  } else if (!match.item[secretField]) {
    code = 'SECRET_NOT_SET';
  }

  const secretFieldInstance = list.fieldsByPath[secretField];

  if (code) {
    // See "Identity Protection" in the README as to why this is a thing
    if (protectIdentities) {
      await secretFieldInstance.generateHash('simulated-password-to-counter-timing-attack');
      code = 'FAILURE';
    }

    return {
      success: false,
      code
    };
  }

  const {
    item
  } = match;

  if (await secretFieldInstance.compare(secret, item[secretField])) {
    // Authenticated!
    return {
      success: true,
      item
    };
  } else {
    return {
      success: false,
      code: protectIdentities ? 'FAILURE' : 'SECRET_MISMATCH'
    };
  }
}

function getPasswordAuthError({
  identityField,
  secretField,
  code,
  itemPlural,
  itemSingular
}) {
  switch (code) {
    case 'FAILURE':
      return 'Authentication failed.';

    case 'IDENTITY_NOT_FOUND':
      return `The ${identityField} value provided didn't identify any ${itemPlural}.`;

    case 'SECRET_NOT_SET':
      return `The ${itemSingular} identified has no ${secretField} set so can not be authenticated.`;

    case 'MULTIPLE_IDENTITY_MATCHES':
      return `The ${identityField} value provided identified more than one ${itemSingular}.`;

    case 'SECRET_MISMATCH':
      return `The ${secretField} provided is incorrect.`;
  }
}
function getAuthTokenErrorMessage({
  identityField,
  code,
  itemPlural,
  itemSingular
}) {
  switch (code) {
    case 'FAILURE':
      return 'Auth token redemption failed.';

    case 'IDENTITY_NOT_FOUND':
      return `The ${identityField} value provided didn't identify any ${itemPlural}.`;

    case 'MULTIPLE_IDENTITY_MATCHES':
      return `The ${identityField} value provided identified more than one ${itemSingular}.`;

    case 'TOKEN_NOT_SET':
      return `The ${itemSingular} identified has no auth token of this type set.`;

    case 'TOKEN_MISMATCH':
      return 'The auth token provided is incorrect.';

    case 'TOKEN_EXPIRED':
      return 'The auth token provided has expired.';

    case 'TOKEN_REDEEMED':
      return 'Auth tokens are single use and the auth token provided has already been redeemed.';
  }
}

function getBaseAuthSchema({
  listKey,
  identityField,
  secretField,
  protectIdentities,
  gqlNames
}) {
  return {
    typeDefs: `
      # Auth
      union AuthenticatedItem = ${listKey}
      type Query {
        authenticatedItem: AuthenticatedItem
      }
      # Password auth
      type Mutation {
        ${gqlNames.authenticateItemWithPassword}(${identityField}: String!, ${secretField}: String!): ${gqlNames.ItemAuthenticationWithPasswordResult}!
      }
      union ${gqlNames.ItemAuthenticationWithPasswordResult} = ${gqlNames.ItemAuthenticationWithPasswordSuccess} | ${gqlNames.ItemAuthenticationWithPasswordFailure}
      type ${gqlNames.ItemAuthenticationWithPasswordSuccess} {
        sessionToken: String!
        item: ${listKey}!
      }
      type ${gqlNames.ItemAuthenticationWithPasswordFailure} {
        code: PasswordAuthErrorCode!
        message: String!
      }
      enum PasswordAuthErrorCode {
        FAILURE
        IDENTITY_NOT_FOUND
        SECRET_NOT_SET
        MULTIPLE_IDENTITY_MATCHES
        SECRET_MISMATCH
      }
    `,
    resolvers: {
      Mutation: {
        async [gqlNames.authenticateItemWithPassword](root, args, context) {
          if (!context.startSession) {
            throw new Error('No session implementation available on context');
          }

          const list = context.keystone.lists[listKey];
          const sudoContext = context.createContext({
            skipAccessControl: true
          });
          const itemAPI = sudoContext.lists[listKey];
          const result = await validateSecret(list, identityField, args[identityField], secretField, protectIdentities, args[secretField], itemAPI);

          if (!result.success) {
            const message = getPasswordAuthError({
              identityField,
              secretField,
              itemSingular: list.adminUILabels.singular,
              itemPlural: list.adminUILabels.plural,
              code: result.code
            });
            return {
              code: result.code,
              message
            };
          } // Update system state


          const sessionToken = await context.startSession({
            listKey,
            itemId: result.item.id
          });
          return {
            sessionToken,
            item: result.item
          };
        }

      },
      Query: {
        async authenticatedItem(root, args, {
          session,
          lists
        }) {
          if (typeof (session === null || session === void 0 ? void 0 : session.itemId) === 'string' && typeof session.listKey === 'string') {
            try {
              return lists[session.listKey].findOne({
                where: {
                  id: session.itemId
                },
                resolveFields: false
              });
            } catch (e) {
              return null;
            }
          }

          return null;
        }

      },
      AuthenticatedItem: {
        __resolveType(rootVal, {
          session
        }) {
          return session === null || session === void 0 ? void 0 : session.listKey;
        }

      },
      // TODO: Is this the preferred approach for this?
      [gqlNames.ItemAuthenticationWithPasswordResult]: {
        __resolveType(rootVal) {
          return rootVal.sessionToken ? gqlNames.ItemAuthenticationWithPasswordSuccess : gqlNames.ItemAuthenticationWithPasswordFailure;
        }

      }
    }
  };
}

function getInitFirstItemSchema({
  listKey,
  fields,
  itemData,
  gqlNames,
  keystone
}) {
  return {
    typeDefs: `
        input ${gqlNames.CreateInitialInput} {
          ${Array.prototype.concat(...fields.map(fieldPath => keystone.lists[listKey].fieldsByPath[fieldPath].gqlCreateInputFields({
      schemaName: 'public'
    }))).join('\n')}
        }
        type Mutation {
          ${gqlNames.createInitialItem}(data: ${gqlNames.CreateInitialInput}!): ${gqlNames.ItemAuthenticationWithPasswordSuccess}!
        }
      `,
    resolvers: {
      Mutation: {
        async [gqlNames.createInitialItem](root, {
          data
        }, context) {
          if (!context.startSession) {
            throw new Error('No session implementation available on context');
          }

          const sudoContext = context.createContext({
            skipAccessControl: true
          });
          const itemAPI = sudoContext.lists[listKey];
          const count = await itemAPI.count({});

          if (count !== 0) {
            throw new Error('Initial items can only be created when no items exist in that list');
          } // Update system state


          const item = await itemAPI.createOne({
            data: _objectSpread(_objectSpread({}, data), itemData),
            resolveFields: false
          });
          const sessionToken = await context.startSession({
            listKey,
            itemId: item.id
          });
          return {
            item,
            sessionToken
          };
        }

      }
    }
  };
}

function generateToken(length) {
  return randomBytes(length) // Generates N*8 bits of data
  .toString('base64') // Groups by 6-bits and encodes as ascii chars in [A-Za-z0-9+/] and '=' for padding (~8/6 * N chars)
  .replace(/[^a-zA-Z0-9]/g, '') // Removes any '+', '/' (62, 63) and '=' chars as often require escaping (eg. in urls)
  .slice(0, length); // Shortens the string, so we now have ~6*N bits of data (it's actually log2(62)*N = 5.954*N)
} // TODO: Auth token mutations may leak user identities due to timing attacks :(
// We don't (currently) make any effort to mitigate the time taken to record the new token or sent the email when successful


async function updateAuthToken(identityField, protectIdentities, identity, itemAPI) {
  const match = await findMatchingIdentity(identityField, identity, itemAPI); // Identity failures with helpful errors (unless it would violate our protectIdentities config)

  if (match.success) {
    return {
      success: true,
      itemId: match.item.id,
      token: generateToken(20)
    };
  } else {
    // There is no generic `AUTH_TOKEN_REQUEST_FAILURE` code; it's existance would alow values in the identity field to be probed
    return {
      success: false,
      code: protectIdentities ? undefined : match.code
    };
  }
}

function sanitiseValidForMinsConfig(input) {
  const parsed = Number.parseFloat(input); // > 10 seconds, < 24 hrs, default 10 mins

  return parsed ? Math.max(1 / 6, Math.min(parsed, 60 * 24)) : 10;
}

async function validateAuthToken(tokenType, list, identityField, identity, protectIdentities, tokenValidMins, token, itemAPI) {
  const result = await validateSecret(list, identityField, identity, `${tokenType}Token`, protectIdentities, token, itemAPI);

  if (!result.success) {
    // Rewrite error codes
    if (result.code === 'SECRET_NOT_SET') return {
      success: false,
      code: 'TOKEN_NOT_SET'
    };
    if (result.code === 'SECRET_MISMATCH') return {
      success: false,
      code: 'TOKEN_MISMATCH'
    };
    return result;
  } // Now that we know the identity and token are valid, we can always return 'helpful' errors and stop worrying about protectIdentities


  const {
    item
  } = result;
  const fieldKeys = {
    issuedAt: `${tokenType}IssuedAt`,
    redeemedAt: `${tokenType}RedeemedAt`
  }; // Check that the token has not been redeemed already

  if (item[fieldKeys.redeemedAt]) {
    return {
      success: false,
      code: 'TOKEN_REDEEMED'
    };
  } // Check that the token has not expired


  if (!item[fieldKeys.issuedAt] || typeof item[fieldKeys.issuedAt].getTime !== 'function') {
    throw new Error(`Error redeeming authToken: field ${list.listKey}.${fieldKeys.issuedAt} isn't a valid Date object.`);
  }

  const elapsedMins = (Date.now() - item[fieldKeys.issuedAt].getTime()) / (1000 * 60);
  const validForMins = sanitiseValidForMinsConfig(tokenValidMins);

  if (elapsedMins > validForMins) {
    return {
      success: false,
      code: 'TOKEN_EXPIRED'
    };
  } // Authenticated!


  return {
    success: true,
    item
  };
}

function getPasswordResetSchema({
  listKey,
  identityField,
  secretField,
  protectIdentities,
  gqlNames,
  passwordResetLink
}) {
  return {
    typeDefs: `
      # Reset password
      type Mutation {
        ${gqlNames.sendItemPasswordResetLink}(${identityField}: String!): ${gqlNames.SendItemPasswordResetLinkResult}
      }
      type ${gqlNames.SendItemPasswordResetLinkResult} {
        code: PasswordResetRequestErrorCode!
        message: String!
      }
      enum PasswordResetRequestErrorCode {
        IDENTITY_NOT_FOUND
        MULTIPLE_IDENTITY_MATCHES
      }
      type Query {
        ${gqlNames.validateItemPasswordResetToken}(${identityField}: String!, token: String!): ${gqlNames.ValidateItemPasswordResetTokenResult}
      }
      type ${gqlNames.ValidateItemPasswordResetTokenResult} {
        code: PasswordResetRedemptionErrorCode!
        message: String!
      }
      type Mutation {
        ${gqlNames.redeemItemPasswordResetToken}(${identityField}: String!, token: String!, ${secretField}: String!): ${gqlNames.RedeemItemPasswordResetTokenResult}
      }
      type ${gqlNames.RedeemItemPasswordResetTokenResult} {
        code: PasswordResetRedemptionErrorCode!
        message: String!
      }
      enum PasswordResetRedemptionErrorCode {
        FAILURE
        IDENTITY_NOT_FOUND
        MULTIPLE_IDENTITY_MATCHES
        TOKEN_NOT_SET
        TOKEN_MISMATCH
        TOKEN_EXPIRED
        TOKEN_REDEEMED
      }
    `,
    resolvers: {
      Mutation: {
        async [gqlNames.sendItemPasswordResetLink](root, args, context) {
          const list = context.keystone.lists[listKey];
          const sudoContext = context.createContext({
            skipAccessControl: true
          });
          const itemAPI = sudoContext.lists[listKey];
          const tokenType = 'passwordReset';
          const identity = args[identityField];
          const result = await updateAuthToken(identityField, protectIdentities, identity, itemAPI); // Note: `success` can be false with no code

          if (!result.success && result.code) {
            const message = getAuthTokenErrorMessage({
              identityField,
              itemSingular: list.adminUILabels.singular,
              itemPlural: list.adminUILabels.plural,
              code: result.code
            });
            return {
              code: result.code,
              message
            };
          } // Update system state


          if (result.success) {
            // Save the token and related info back to the item
            const {
              token,
              itemId
            } = result;
            await itemAPI.updateOne({
              id: `${itemId}`,
              data: {
                [`${tokenType}Token`]: token,
                [`${tokenType}IssuedAt`]: new Date().toISOString(),
                [`${tokenType}RedeemedAt`]: null
              },
              resolveFields: false
            });
            await passwordResetLink.sendToken({
              itemId,
              identity,
              token
            });
          }

          return null;
        },

        async [gqlNames.redeemItemPasswordResetToken](root, args, context) {
          const list = context.keystone.lists[listKey];
          const sudoContext = context.createContext({
            skipAccessControl: true
          });
          const itemAPI = sudoContext.lists[listKey];
          const tokenType = 'passwordReset';
          const result = await validateAuthToken(tokenType, list, identityField, args[identityField], protectIdentities, passwordResetLink.tokensValidForMins, args.token, itemAPI);

          if (!result.success) {
            const message = getAuthTokenErrorMessage({
              identityField,
              itemSingular: list.adminUILabels.singular,
              itemPlural: list.adminUILabels.plural,
              code: result.code
            });
            return {
              code: result.code,
              message
            };
          } // Update system state


          const itemId = result.item.id; // Save the token and related info back to the item

          await itemAPI.updateOne({
            id: itemId,
            data: {
              [`${tokenType}RedeemedAt`]: new Date().toISOString()
            },
            resolveFields: false
          }); // Save the provided secret. Do this as a separate step as password validation
          // may fail, in which case we still want to mark the token as redeemed
          // (NB: Is this *really* what we want? -TL)

          await itemAPI.updateOne({
            id: itemId,
            data: {
              [secretField]: args[secretField]
            },
            resolveFields: false
          });
          return null;
        }

      },
      Query: {
        async [gqlNames.validateItemPasswordResetToken](root, args, context) {
          const list = context.keystone.lists[listKey];
          const sudoContext = context.createContext({
            skipAccessControl: true
          });
          const itemAPI = sudoContext.lists[listKey];
          const tokenType = 'passwordReset';
          const result = await validateAuthToken(tokenType, list, identityField, args[identityField], protectIdentities, passwordResetLink.tokensValidForMins, args.token, itemAPI);

          if (!result.success && result.code) {
            const message = getAuthTokenErrorMessage({
              identityField,
              itemSingular: list.adminUILabels.singular,
              itemPlural: list.adminUILabels.plural,
              code: result.code
            });
            return {
              code: result.code,
              message
            };
          }

          return null;
        }

      }
    }
  };
}

function getMagicAuthLinkSchema({
  listKey,
  identityField,
  protectIdentities,
  gqlNames,
  magicAuthLink
}) {
  return {
    typeDefs: `
      # Magic links
      type Mutation {
        ${gqlNames.sendItemMagicAuthLink}(${identityField}: String!): ${gqlNames.SendItemMagicAuthLinkResult}
      }
      type ${gqlNames.SendItemMagicAuthLinkResult} {
        code: MagicLinkRequestErrorCode!
        message: String!
      }
      enum MagicLinkRequestErrorCode {
        IDENTITY_NOT_FOUND
        MULTIPLE_IDENTITY_MATCHES
      }
      type Mutation {
        ${gqlNames.redeemItemMagicAuthToken}(${identityField}: String!, token: String!): ${gqlNames.RedeemItemMagicAuthTokenResult}!
      }
      union ${gqlNames.RedeemItemMagicAuthTokenResult} = ${gqlNames.RedeemItemMagicAuthTokenSuccess} | ${gqlNames.RedeemItemMagicAuthTokenFailure}
      type ${gqlNames.RedeemItemMagicAuthTokenSuccess} {
        token: String!
        item: ${listKey}!
      }
      type ${gqlNames.RedeemItemMagicAuthTokenFailure} {
        code: MagicLinkRedemptionErrorCode!
        message: String!
      }
      enum MagicLinkRedemptionErrorCode {
        FAILURE
        IDENTITY_NOT_FOUND
        MULTIPLE_IDENTITY_MATCHES
        TOKEN_NOT_SET
        TOKEN_MISMATCH
        TOKEN_EXPIRED
        TOKEN_REDEEMED
      }
    `,
    resolvers: {
      Mutation: {
        async [gqlNames.sendItemMagicAuthLink](root, args, context) {
          const list = context.keystone.lists[listKey];
          const sudoContext = context.createContext({
            skipAccessControl: true
          });
          const itemAPI = sudoContext.lists[listKey];
          const tokenType = 'magicAuth';
          const identity = args[identityField];
          const result = await updateAuthToken(identityField, protectIdentities, identity, itemAPI); // Note: `success` can be false with no code

          if (!result.success && result.code) {
            const message = getAuthTokenErrorMessage({
              identityField,
              itemSingular: list.adminUILabels.singular,
              itemPlural: list.adminUILabels.plural,
              code: result.code
            });
            return {
              code: result.code,
              message
            };
          } // Update system state


          if (result.success) {
            // Save the token and related info back to the item
            const {
              token,
              itemId
            } = result;
            await itemAPI.updateOne({
              id: `${itemId}`,
              data: {
                [`${tokenType}Token`]: token,
                [`${tokenType}IssuedAt`]: new Date().toISOString(),
                [`${tokenType}RedeemedAt`]: null
              },
              resolveFields: false
            });
            await magicAuthLink.sendToken({
              itemId,
              identity,
              token
            });
          }

          return null;
        },

        async [gqlNames.redeemItemMagicAuthToken](root, args, context) {
          if (!context.startSession) {
            throw new Error('No session implementation available on context');
          }

          const list = context.keystone.lists[listKey];
          const sudoContext = context.createContext({
            skipAccessControl: true
          });
          const itemAPI = sudoContext.lists[listKey];
          const tokenType = 'magicAuth';
          const result = await validateAuthToken(tokenType, list, identityField, args[identityField], protectIdentities, magicAuthLink.tokensValidForMins, args.token, itemAPI);

          if (!result.success) {
            const message = getAuthTokenErrorMessage({
              identityField,
              itemSingular: list.adminUILabels.singular,
              itemPlural: list.adminUILabels.plural,
              code: result.code
            });
            return {
              code: result.code,
              message
            };
          } // Update system state
          // Save the token and related info back to the item


          await itemAPI.updateOne({
            id: result.item.id,
            data: {
              [`${tokenType}RedeemedAt`]: new Date().toISOString()
            },
            resolveFields: false
          });
          const sessionToken = await context.startSession({
            listKey,
            itemId: result.item.id
          });
          return {
            token: sessionToken,
            item: result.item
          };
        }

      },
      // TODO: Is this the preferred approach for this?
      [gqlNames.RedeemItemMagicAuthTokenResult]: {
        __resolveType(rootVal) {
          return rootVal.token ? gqlNames.RedeemItemMagicAuthTokenSuccess : gqlNames.RedeemItemMagicAuthTokenFailure;
        }

      }
    }
  };
}

const signinTemplate = ({
  gqlNames,
  identityField,
  secretField
}) => {
  // -- TEMPLATE START
  return `
import React from 'react';
import { gql } from '@keystone-next/admin-ui/apollo';
import { SigninPage } from '@keystone-next/auth/pages/SigninPage'

export default function Signin() {
  return <SigninPage
           identityField="${identityField}"
           secretField="${secretField}"
           mutationName="${gqlNames.authenticateItemWithPassword}"
           successTypename="${gqlNames.ItemAuthenticationWithPasswordSuccess}"
           failureTypename="${gqlNames.ItemAuthenticationWithPasswordFailure}"
         />
}
  `; // -- TEMPLATE END
};

const initTemplate = ({
  listKey,
  initFirstItem
}) => {
  // -- TEMPLATE START
  return `import { InitPage } from '@keystone-next/auth/pages/InitPage';
  import React from 'react';
  import { gql } from '@keystone-next/admin-ui/apollo';

  const fieldPaths = ${JSON.stringify(initFirstItem.fields)};

  export default function Init() {
    return <InitPage listKey="${listKey}" fieldPaths={fieldPaths} showKeystoneSignup={${JSON.stringify(!initFirstItem.skipKeystoneSignup)}} />
  }
  `; // -- TEMPLATE END
};

const getSchemaExtension = ({
  identityField,
  listKey,
  protectIdentities,
  secretField,
  gqlNames,
  initFirstItem,
  passwordResetLink,
  magicAuthLink
}) => (schema, keystone) => [getBaseAuthSchema({
  identityField,
  listKey,
  protectIdentities,
  secretField,
  gqlNames
}), initFirstItem && getInitFirstItemSchema({
  listKey,
  fields: initFirstItem.fields,
  itemData: initFirstItem.itemData,
  gqlNames,
  keystone
}), passwordResetLink && getPasswordResetSchema({
  identityField,
  listKey,
  protectIdentities,
  secretField,
  passwordResetLink,
  gqlNames
}), magicAuthLink && getMagicAuthLinkSchema({
  identityField,
  listKey,
  protectIdentities,
  magicAuthLink,
  gqlNames
})].filter(x => x).reduce((s, extension) => mergeSchemas(_objectSpread({
  schemas: [s]
}, extension)), schema);
/**
 * createAuth function
 *
 * Generates config for Keystone to implement standard auth features.
 */


function createAuth({
  listKey,
  secretField,
  protectIdentities = true,
  gqlSuffix = '',
  initFirstItem,
  identityField,
  magicAuthLink,
  passwordResetLink
}) {
  const gqlNames = {
    CreateInitialInput: `CreateInitial${listKey}Input${gqlSuffix}`,
    createInitialItem: `createInitial${listKey}${gqlSuffix}`,
    authenticateItemWithPassword: `authenticate${listKey}WithPassword${gqlSuffix}`,
    ItemAuthenticationWithPasswordResult: `${listKey}AuthenticationWithPasswordResult${gqlSuffix}`,
    ItemAuthenticationWithPasswordSuccess: `${listKey}AuthenticationWithPasswordSuccess${gqlSuffix}`,
    ItemAuthenticationWithPasswordFailure: `${listKey}AuthenticationWithPasswordFailure${gqlSuffix}`,
    sendItemPasswordResetLink: `send${listKey}PasswordResetLink${gqlSuffix}`,
    SendItemPasswordResetLinkResult: `Send${listKey}PasswordResetLinkResult${gqlSuffix}`,
    validateItemPasswordResetToken: `validate${listKey}PasswordResetToken${gqlSuffix}`,
    ValidateItemPasswordResetTokenResult: `Validate${listKey}PasswordResetTokenResult${gqlSuffix}`,
    redeemItemPasswordResetToken: `redeem${listKey}PasswordResetToken${gqlSuffix}`,
    RedeemItemPasswordResetTokenResult: `Redeem${listKey}PasswordResetTokenResult${gqlSuffix}`,
    sendItemMagicAuthLink: `send${listKey}MagicAuthLink${gqlSuffix}`,
    SendItemMagicAuthLinkResult: `Send${listKey}MagicAuthLinkResult${gqlSuffix}`,
    redeemItemMagicAuthToken: `redeem${listKey}MagicAuthToken${gqlSuffix}`,
    RedeemItemMagicAuthTokenResult: `Redeem${listKey}MagicAuthTokenResult${gqlSuffix}`,
    RedeemItemMagicAuthTokenSuccess: `Redeem${listKey}MagicAuthTokenSuccess${gqlSuffix}`,
    RedeemItemMagicAuthTokenFailure: `Redeem${listKey}MagicAuthTokenFailure${gqlSuffix}`
  }; // Fields added to the auth list
  // TODO: These access control settings are not static, because we're still using executGraphQL
  // internally and stataic false excludes them from the schema. When the implementation is
  // updated to use our crud API, we can set these to static false values.

  const fieldConfig = {
    access: () => false,
    ui: {
      createView: {
        fieldMode: 'hidden'
      },
      itemView: {
        fieldMode: 'hidden'
      },
      listView: {
        fieldMode: 'hidden'
      }
    }
  };
  const additionalListFields = {
    [`${secretField}ResetToken`]: password(_objectSpread({}, fieldConfig)),
    [`${secretField}ResetIssuedAt`]: timestamp(_objectSpread({}, fieldConfig)),
    [`${secretField}ResetRedeemedAt`]: timestamp(_objectSpread({}, fieldConfig)),
    [`magicAuthToken`]: password(_objectSpread({}, fieldConfig)),
    [`magicAuthIssuedAt`]: timestamp(_objectSpread({}, fieldConfig)),
    [`magicAuthRedeemedAt`]: timestamp(_objectSpread({}, fieldConfig))
  };
  /**
   * adminPageMiddleware
   *
   * Should be added to the ui.pageMiddleware stack.
   *
   * Redirects:
   *  - from the signin or init pages to the index when a valid session is present
   *  - to the init page when initFirstItem is configured, and there are no user in the database
   *  - to the signin page when no valid session is present
   */

  const adminPageMiddleware = async ({
    req,
    isValidSession,
    createContext,
    session
  }) => {
    const pathname = url.parse(req.url).pathname;

    if (isValidSession) {
      if (pathname === '/signin' || initFirstItem && pathname === '/init') {
        return {
          kind: 'redirect',
          to: '/'
        };
      }

      return;
    }

    if (!session && initFirstItem) {
      const count = await createContext({
        skipAccessControl: true
      }).lists[listKey].count({});

      if (count === 0) {
        if (pathname !== '/init') {
          return {
            kind: 'redirect',
            to: '/init'
          };
        }

        return;
      }
    }

    if (!session && pathname !== '/signin') {
      return {
        kind: 'redirect',
        to: `/signin?from=${encodeURIComponent(req.url)}`
      };
    }
  };
  /**
   * additionalFiles
   *
   * This function adds files to be generated into the Admin UI build. Must be added to the
   * ui.additionalFiles config.
   *
   * The signin page is always included, and the init page is included when initFirstItem is set
   */


  const additionalFiles = () => {
    let filesToWrite = [{
      mode: 'write',
      outputPath: 'pages/signin.js',
      src: signinTemplate({
        gqlNames,
        identityField,
        secretField
      })
    }];

    if (initFirstItem) {
      filesToWrite.push({
        mode: 'write',
        outputPath: 'pages/init.js',
        // wonder what this template expects from config...
        src: initTemplate({
          listKey,
          initFirstItem
        })
      });
    }

    return filesToWrite;
  };
  /**
   * publicAuthPages
   *
   * Must be added to the ui.publicPages config
   */


  const publicAuthPages = ['/signin', '/init'];
  /**
   * extendGraphqlSchema
   *
   * Must be added to the extendGraphqlSchema config. Can be composed.
   */

  const extendGraphqlSchema = getSchemaExtension({
    identityField,
    listKey,
    protectIdentities,
    secretField,
    gqlNames,
    initFirstItem,
    passwordResetLink,
    magicAuthLink
  });
  /**
   * validateConfig
   *
   * Validates the provided auth config; optional step when integrating auth
   */

  const validateConfig = keystoneConfig => {
    const specifiedListConfig = keystoneConfig.lists[listKey];

    if (keystoneConfig.lists[listKey] === undefined) {
      throw new Error(`A createAuth() invocation specifies the list "${listKey}" but no list with that key has been defined.`);
    } // TODO: Check for String-like typing for identityField? How?


    const identityFieldConfig = specifiedListConfig.fields[identityField];

    if (identityFieldConfig === undefined) {
      throw new Error(`A createAuth() invocation for the "${listKey}" list specifies ${JSON.stringify(identityField)} as its identityField but no field with that key exists on the list.`);
    } // TODO: We could make the secret field optional to disable the standard id/secret auth and password resets (ie. magic links only)


    const secretFieldConfig = specifiedListConfig.fields[secretField];

    if (secretFieldConfig === undefined) {
      throw new Error(`A createAuth() invocation for the "${listKey}" list specifies ${JSON.stringify(secretField)} as its secretField but no field with that key exists on the list.`);
    }

    const secretPrototype = secretFieldConfig.type && secretFieldConfig.type.implementation && secretFieldConfig.type.implementation.prototype;
    const secretTypename = secretFieldConfig.type && secretFieldConfig.type.type;

    if (typeof secretPrototype.compare !== 'function' || secretPrototype.compare.length < 2) {
      throw new Error(`A createAuth() invocation for the "${listKey}" list specifies ${JSON.stringify(secretField)} as its secretField, which uses the field type ${JSON.stringify(secretTypename)}. But the ${JSON.stringify(secretTypename)} field type doesn't implement the required compare() functionality.` + (secretTypename !== 'Password' ? ` Did you mean to reference a field of type Password instead?` : ''));
    }

    if (typeof secretPrototype.generateHash !== 'function') {
      throw new Error(`A createAuth() invocation for the "${listKey}" list specifies ${JSON.stringify(secretField)} as its secretField, which uses the field type ${JSON.stringify(secretTypename)}. But the ${JSON.stringify(secretTypename)} field type doesn't implement the required generateHash() functionality.` + (secretTypename !== 'Password' ? ` Did you mean to reference a field of type Password instead?` : ''));
    } // TODO: Could also validate initFirstItem.itemData keys?


    for (const field of (initFirstItem === null || initFirstItem === void 0 ? void 0 : initFirstItem.fields) || []) {
      if (specifiedListConfig.fields[field] === undefined) {
        throw new Error(`A createAuth() invocation for the "${listKey}" list specifies the field ${JSON.stringify(field)} in initFirstItem.fields array but no field with that key exist on the list.`);
      }
    }
  };
  /**
   * withAuth
   *
   * Automatically extends config with the correct auth functionality. This is the easiest way to
   * configure auth for keystone; you should probably use it unless you want to extend or replace
   * the way auth is set up with custom functionality.
   *
   * It validates the auth config against the provided keystone config, and preserves existing
   * config by composing existing extendGraphqlSchema functions and ui config.
   */


  const withAuth = keystoneConfig => {
    validateConfig(keystoneConfig);
    let ui = keystoneConfig.ui;

    if (keystoneConfig.ui) {
      ui = _objectSpread(_objectSpread({}, keystoneConfig.ui), {}, {
        publicPages: [...(keystoneConfig.ui.publicPages || []), ...publicAuthPages],
        getAdditionalFiles: [...(keystoneConfig.ui.getAdditionalFiles || []), additionalFiles],
        pageMiddleware: async args => {
          var _await$adminPageMiddl, _keystoneConfig$ui, _keystoneConfig$ui$pa;

          return (_await$adminPageMiddl = await adminPageMiddleware(args)) !== null && _await$adminPageMiddl !== void 0 ? _await$adminPageMiddl : keystoneConfig === null || keystoneConfig === void 0 ? void 0 : (_keystoneConfig$ui = keystoneConfig.ui) === null || _keystoneConfig$ui === void 0 ? void 0 : (_keystoneConfig$ui$pa = _keystoneConfig$ui.pageMiddleware) === null || _keystoneConfig$ui$pa === void 0 ? void 0 : _keystoneConfig$ui$pa.call(_keystoneConfig$ui, args);
        },
        enableSessionItem: true,
        isAccessAllowed: async context => {
          var _context$req, _keystoneConfig$ui2;

          // Allow access to the adminMeta data from the /init path to correctly render that page
          // even if the user isn't logged in (which should always be the case if they're seeing /init)
          const headers = (_context$req = context.req) === null || _context$req === void 0 ? void 0 : _context$req.headers;
          const url = headers !== null && headers !== void 0 && headers.referer ? new URL(headers.referer) : undefined;
          const accessingInitPage = (url === null || url === void 0 ? void 0 : url.pathname) === '/init' && (url === null || url === void 0 ? void 0 : url.host) === (headers === null || headers === void 0 ? void 0 : headers.host) && (await context.createContext({
            skipAccessControl: true
          }).lists[listKey].count({})) === 0;
          return accessingInitPage || ((_keystoneConfig$ui2 = keystoneConfig.ui) !== null && _keystoneConfig$ui2 !== void 0 && _keystoneConfig$ui2.isAccessAllowed ? keystoneConfig.ui.isAccessAllowed(context) : context.session !== undefined);
        }
      });
    }

    const existingExtendGraphQLSchema = keystoneConfig.extendGraphqlSchema;
    return _objectSpread(_objectSpread({}, keystoneConfig), {}, {
      ui,
      // Add the additional fields to the references lists fields object
      // TODO: The additionalListFields we're adding here shouldn't naively replace existing fields with the same key
      // Leaving existing fields in place would allow solution devs to customise these field defs (eg. access control,
      // work factor for the tokens, etc.) without abandoning the withAuth() interface
      lists: _objectSpread(_objectSpread({}, keystoneConfig.lists), {}, {
        [listKey]: _objectSpread(_objectSpread({}, keystoneConfig.lists[listKey]), {}, {
          fields: _objectSpread(_objectSpread({}, keystoneConfig.lists[listKey].fields), additionalListFields)
        })
      }),
      extendGraphqlSchema: existingExtendGraphQLSchema ? (schema, keystone) => existingExtendGraphQLSchema(extendGraphqlSchema(schema, keystone), keystone) : extendGraphqlSchema
    });
  };
  /**
   * Alongside withAuth (recommended) all the config is returned so you can extend or replace
   * the default implementation with your own custom functionality, and integrate the result into
   * your keystone config by hand.
   */


  return {
    ui: {
      enableSessionItem: true,
      pageMiddleware: adminPageMiddleware,
      publicPages: publicAuthPages,
      getAdditionalFiles: additionalFiles
    },
    fields: additionalListFields,
    extendGraphqlSchema,
    validateConfig,
    withAuth
  };
}

export { createAuth };
