'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var graphql = require('graphql');
var merge = require('@graphql-tools/merge');
var utils = require('@graphql-tools/utils');
var schema = require('@graphql-tools/schema');
var system = require('@keystone-next/admin-ui/system');
var schema$1 = require('./schema-b1ee2f14.cjs.dev.js');
var serverSideGraphqlClient = require('@keystonejs/server-side-graphql-client');
var values = require('graphql/execution/values');
var path = require('path');
var keystone = require('@keystonejs/keystone');
var adapterMongoose = require('@keystonejs/adapter-mongoose');
var adapterKnex = require('@keystonejs/adapter-knex');
var adapterPrisma = require('@keystonejs/adapter-prisma');
var fields = require('@keystone-next/fields');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefault(path);

function createGraphQLSchema(config, keystone) {
  // Start with the core keystone graphQL schema
  let graphQLSchema = schema.makeExecutableSchema({
    typeDefs: keystone.getTypeDefs({
      schemaName: 'public'
    }),
    resolvers: keystone.getResolvers({
      schemaName: 'public'
    })
  }); // Filter out the _label_ field from all lists

  graphQLSchema = utils.mapSchema(graphQLSchema, {
    'MapperKind.OBJECT_TYPE'(type) {
      if (config.lists[type.name] !== undefined && config.lists[type.name].fields._label_ === undefined) {
        let _type$toConfig = type.toConfig(),
            fields = _objectWithoutProperties(_type$toConfig.fields, ["_label_"]),
            objectTypeConfig = _objectWithoutProperties(_type$toConfig, ["fields"]);

        return new graphql.GraphQLObjectType(_objectSpread({
          fields
        }, objectTypeConfig));
      }

      return type;
    }

  }); // TODO: find a way to not pass keystone in here, if we can - it's too broad and makes
  // everything in the keystone instance public API
  // Merge in the user defined graphQL API

  if (config.extendGraphqlSchema) {
    graphQLSchema = config.extendGraphqlSchema(graphQLSchema, keystone);
  } // Merge in session graphQL API


  if (config.session) {
    graphQLSchema = merge.mergeSchemas({
      schemas: [graphQLSchema],
      typeDefs: schema$1.gql`
        type Mutation {
          endSession: Boolean!
        }
      `,
      resolvers: {
        Mutation: {
          async endSession(rootVal, args, context) {
            if (context.endSession) {
              await context.endSession();
            }

            return true;
          }

        }
      }
    });
  } // Merge in the admin-meta graphQL API


  graphQLSchema = merge.mergeSchemas(_objectSpread({
    schemas: [graphQLSchema]
  }, system.getAdminMetaSchema({
    keystone,
    config
  })));
  return graphQLSchema;
}

function getNamedOrListTypeNodeForType(type) {
  if (type instanceof graphql.GraphQLList) {
    return {
      kind: 'ListType',
      type: getTypeNodeForType(type.ofType)
    };
  }

  return {
    kind: 'NamedType',
    name: {
      kind: 'Name',
      value: type.name
    }
  };
}

function getTypeNodeForType(type) {
  if (type instanceof graphql.GraphQLNonNull) {
    return {
      kind: 'NonNullType',
      type: getNamedOrListTypeNodeForType(type.ofType)
    };
  }

  return getNamedOrListTypeNodeForType(type);
}

function getCoerceAndValidateArgumentsFnForGraphQLField(schema, field) {
  const variableDefintions = [];

  for (const arg of field.args) {
    variableDefintions.push({
      kind: 'VariableDefinition',
      type: getTypeNodeForType(arg.type),
      variable: {
        kind: 'Variable',
        name: {
          kind: 'Name',
          value: `${arg.name}`
        }
      }
    });
  }

  const fieldNode = {
    kind: 'Field',
    name: {
      kind: 'Name',
      value: field.name
    },
    arguments: field.args.map(arg => ({
      kind: 'Argument',
      name: {
        kind: 'Name',
        value: arg.name
      },
      value: {
        kind: 'Variable',
        name: {
          kind: 'Name',
          value: `${arg.name}`
        }
      }
    }))
  };
  return args => {
    const coercedVariableValues = values.getVariableValues(schema, variableDefintions, args);

    if (coercedVariableValues.errors) {
      throw coercedVariableValues.errors[0];
    }

    return values.getArgumentValues(field, fieldNode, coercedVariableValues.coerced);
  };
}

function getArgsFactory(list, schema) {
  const queryFields = schema.getQueryType().getFields();
  const mutationFields = schema.getMutationType().getFields();
  const f = getCoerceAndValidateArgumentsFnForGraphQLField;
  return {
    findOne: f(schema, queryFields[list.gqlNames.itemQueryName]),
    findMany: f(schema, queryFields[list.gqlNames.listQueryName]),
    count: f(schema, queryFields[list.gqlNames.listQueryMetaName]),
    createOne: f(schema, mutationFields[list.gqlNames.createMutationName]),
    createMany: f(schema, mutationFields[list.gqlNames.createManyMutationName]),
    updateOne: f(schema, mutationFields[list.gqlNames.updateMutationName]),
    updateMany: f(schema, mutationFields[list.gqlNames.updateManyMutationName]),
    deleteOne: f(schema, mutationFields[list.gqlNames.deleteMutationName]),
    deleteMany: f(schema, mutationFields[list.gqlNames.deleteManyMutationName])
  };
}
function itemAPIForList(list, context, getArgs) {
  const listKey = list.key;
  return {
    findOne(_ref) {
      let {
        resolveFields = 'id'
      } = _ref,
          rawArgs = _objectWithoutProperties(_ref, ["resolveFields"]);

      const args = getArgs.findOne(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClient.getItem({
          listKey,
          context,
          returnFields: resolveFields,
          itemId: args.where.id
        });
      } else {
        return list.itemQuery(args, context);
      }
    },

    findMany(_ref2) {
      let {
        resolveFields = 'id'
      } = _ref2,
          rawArgs = _objectWithoutProperties(_ref2, ["resolveFields"]);

      const args = getArgs.findMany(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClient.getItems(_objectSpread({
          listKey,
          context,
          returnFields: resolveFields
        }, args));
      } else {
        return list.listQuery(args, context);
      }
    },

    async count(rawArgs) {
      const args = getArgs.count(rawArgs);
      return (await list.listQueryMeta(args, context)).getCount();
    },

    createOne(_ref3) {
      let {
        resolveFields = 'id'
      } = _ref3,
          rawArgs = _objectWithoutProperties(_ref3, ["resolveFields"]);

      const {
        data
      } = getArgs.createOne(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClient.createItem({
          listKey,
          context,
          returnFields: resolveFields,
          item: data
        });
      } else {
        return list.createMutation(data, context);
      }
    },

    createMany(_ref4) {
      let {
        resolveFields = 'id'
      } = _ref4,
          rawArgs = _objectWithoutProperties(_ref4, ["resolveFields"]);

      const {
        data
      } = getArgs.createMany(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClient.createItems({
          listKey,
          context,
          returnFields: resolveFields,
          items: data
        });
      } else {
        return list.createManyMutation(data, context);
      }
    },

    updateOne(_ref5) {
      let {
        resolveFields = 'id'
      } = _ref5,
          rawArgs = _objectWithoutProperties(_ref5, ["resolveFields"]);

      const {
        id,
        data
      } = getArgs.updateOne(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClient.updateItem({
          listKey,
          context,
          returnFields: resolveFields,
          item: {
            id,
            data
          }
        });
      } else {
        return list.updateMutation(id, data, context);
      }
    },

    updateMany(_ref6) {
      let {
        resolveFields = 'id'
      } = _ref6,
          rawArgs = _objectWithoutProperties(_ref6, ["resolveFields"]);

      const {
        data
      } = getArgs.updateMany(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClient.updateItems({
          listKey,
          context,
          returnFields: resolveFields,
          items: data
        });
      } else {
        return list.updateManyMutation(data, context);
      }
    },

    deleteOne(_ref7) {
      let {
        resolveFields = 'id'
      } = _ref7,
          rawArgs = _objectWithoutProperties(_ref7, ["resolveFields"]);

      const {
        id
      } = getArgs.deleteOne(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClient.deleteItem({
          listKey,
          context,
          returnFields: resolveFields,
          itemId: id
        });
      } else {
        return list.deleteMutation(id, context);
      }
    },

    deleteMany(_ref8) {
      let {
        resolveFields = 'id'
      } = _ref8,
          rawArgs = _objectWithoutProperties(_ref8, ["resolveFields"]);

      const {
        ids
      } = getArgs.deleteMany(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClient.deleteItems({
          listKey,
          context,
          returnFields: resolveFields,
          items: ids
        });
      } else {
        return list.deleteManyMutation(ids, context);
      }
    }

  };
}

async function validateListAccessControl({
  access,
  listKey,
  operation,
  session,
  originalInput,
  gqlName,
  itemId,
  itemIds,
  context
}) {
  // Either a boolean or an object describing a where clause
  let result;

  if (typeof access[operation] !== 'function') {
    result = access[operation];
  } else {
    result = await access[operation]({
      session,
      listKey,
      operation,
      originalInput,
      gqlName,
      itemId,
      itemIds,
      context
    });
  }

  const type = typeof result;

  if (!['object', 'boolean'].includes(type) || result === null) {
    throw new Error(`Must return an Object or Boolean from Imperative or Declarative access control function. Got ${type}`);
  } // Special case for 'create' permission


  if (operation === 'create' && type === 'object') {
    throw new Error(`Expected a Boolean for ${listKey}.access.create(), but got Object. (NOTE: 'create' cannot have a Declarative access control config)`);
  }

  return result;
}

async function validateFieldAccessControl({
  access,
  listKey,
  fieldKey,
  originalInput,
  item,
  operation,
  session,
  gqlName,
  itemId,
  itemIds,
  context
}) {
  let result;

  if (typeof access[operation] !== 'function') {
    result = access[operation];
  } else {
    result = await access[operation]({
      session,
      listKey,
      fieldKey,
      originalInput,
      item,
      operation,
      gqlName,
      itemId,
      itemIds,
      context
    });
  }

  if (typeof result !== 'boolean') {
    throw new Error(`Must return a Boolean from ${listKey}.fields.${fieldKey}.access.${operation}(). Got ${typeof result}`);
  }

  return result;
} // getCustomAccessControlForUser and getAuthAccessControlForUser do not exist here
// since the places where they're used are not used in the new interfaces


const skipAccessControlContext = {
  getListAccessControlForUser: () => true,
  getFieldAccessControlForUser: () => true
}; // these are memoized in current Keystone but not here
// since it's useless because all of the callers of them pass in new objects
// + the functions will never be called with the same stuff (even ignoring the identity of the objects mentioned above)
// + the memoization library used has a cache size of 1 by default

const accessControlContext = {
  async getListAccessControlForUser(access, listKey, originalInput, operation, {
    gqlName,
    itemId,
    itemIds,
    context
  } = {}) {
    return validateListAccessControl({
      access: access[context.schemaName],
      originalInput,
      operation,
      session: context.session,
      listKey,
      gqlName,
      itemId,
      itemIds,
      context
    });
  },

  async getFieldAccessControlForUser(access, listKey, fieldKey, originalInput, item, operation, {
    gqlName,
    itemId,
    itemIds,
    context
  } = {}) {
    return validateFieldAccessControl({
      access: access[context.schemaName],
      originalInput,
      item,
      operation,
      session: context.session,
      fieldKey,
      listKey,
      gqlName,
      itemId,
      itemIds,
      context
    });
  }

};

function makeCreateContext({
  graphQLSchema,
  keystone
}) {
  // We precompute these helpers here rather than every time createContext is called
  // because they require parsing the entire schema, which is potentially expensive.
  const getArgsByList = {};

  for (const [listKey, list] of Object.entries(keystone.lists)) {
    getArgsByList[listKey] = getArgsFactory(list, graphQLSchema);
  }

  const createContext = ({
    sessionContext,
    skipAccessControl = false,
    req
  } = {}) => {
    const rawGraphQL = ({
      query,
      context,
      variables
    }) => {
      if (typeof query === 'string') {
        query = graphql.parse(query);
      }

      return Promise.resolve(graphql.execute({
        schema: graphQLSchema,
        document: query,
        contextValue: context !== null && context !== void 0 ? context : contextToReturn,
        variableValues: variables
      }));
    };

    const runGraphQL = async args => {
      var _result$errors;

      let result = await rawGraphQL(args);

      if ((_result$errors = result.errors) !== null && _result$errors !== void 0 && _result$errors.length) {
        throw result.errors[0];
      }

      return result.data;
    };

    const itemAPI = {};
    const _sessionContext = sessionContext;
    const _skipAccessControl = skipAccessControl;
    const _req = req;

    const contextToReturn = _objectSpread(_objectSpread(_objectSpread({
      schemaName: 'public'
    }, skipAccessControl ? skipAccessControlContext : accessControlContext), {}, {
      lists: itemAPI,
      totalResults: 0,
      keystone,
      // Only one of these will be available on any given context
      // TODO: Capture that in the type
      knex: keystone.adapter.knex,
      mongoose: keystone.adapter.mongoose,
      prisma: keystone.adapter.prisma,
      graphql: {
        createContext,
        raw: rawGraphQL,
        run: runGraphQL,
        schema: graphQLSchema
      },
      maxTotalResults: keystone.queryLimits.maxTotalResults,
      createContext: ({
        sessionContext = _sessionContext,
        skipAccessControl = _skipAccessControl,
        req = _req
      } = {}) => createContext({
        sessionContext,
        skipAccessControl,
        req
      }),
      req
    }, sessionContext), {}, {
      // Note: These two fields let us use the server-side-graphql-client library.
      // We may want to remove them once the updated itemAPI w/ resolveFields is available.
      executeGraphQL: rawGraphQL,
      gqlNames: listKey => keystone.lists[listKey].gqlNames
    });

    for (const [listKey, list] of Object.entries(keystone.lists)) {
      itemAPI[listKey] = itemAPIForList(list, contextToReturn, getArgsByList[listKey]);
    }

    return contextToReturn;
  };

  return createContext;
}

function createKeystone(config, dotKeystonePath, script) {
  // Note: For backwards compatibility we may want to expose
  // this as a public API so that users can start their transition process
  // by using this pattern for creating their Keystone object before using
  // it in their existing custom servers or original CLI systems.
  const {
    db,
    graphql,
    lists
  } = config;
  let adapter;

  if (db.adapter === 'knex') {
    adapter = new adapterKnex.KnexAdapter({
      knexOptions: {
        connection: db.url
      },
      dropDatabase: db.dropDatabase
    });
  } else if (db.adapter === 'mongoose') {
    adapter = new adapterMongoose.MongooseAdapter(_objectSpread({
      mongoUri: db.url
    }, db.mongooseOptions));
  } else if (db.adapter === 'prisma_postgresql') {
    adapter = new adapterPrisma.PrismaAdapter(_objectSpread({
      getPrismaPath: () => path__default['default'].join(dotKeystonePath, 'prisma'),
      migrationMode: script === 'prototype' ? 'prototype' : script === 'generate' ? 'createOnly' : script === 'start' ? 'none' : 'dev'
    }, db));
  } // @ts-ignore The @types/keystonejs__keystone package has the wrong type for KeystoneOptions


  const keystone$1 = new keystone.Keystone({
    adapter,
    cookieSecret: '123456789',
    // FIXME: Don't provide a default here. See #2882
    queryLimits: graphql === null || graphql === void 0 ? void 0 : graphql.queryLimits,
    // @ts-ignore The @types/keystonejs__keystone package has the wrong type for KeystoneOptions
    onConnect: (keystone, {
      context
    } = {}) => {
      var _config$db$onConnect, _config$db;

      return (_config$db$onConnect = (_config$db = config.db).onConnect) === null || _config$db$onConnect === void 0 ? void 0 : _config$db$onConnect.call(_config$db, context);
    } // FIXME: Unsupported options: Need to work which of these we want to support with backwards
    // compatibility options.
    // defaultAccess
    // sessionStore
    // cookie
    // schemaNames
    // appVersion

  });
  Object.entries(lists).forEach(([key, {
    fields,
    graphql,
    access,
    hooks,
    description
  }]) => {
    var _graphql$description;

    keystone$1.createList(key, {
      fields: Object.fromEntries(Object.entries(fields).map(([key, {
        type,
        config
      }]) => [key, _objectSpread({
        type
      }, config)])),
      access,
      queryLimits: graphql === null || graphql === void 0 ? void 0 : graphql.queryLimits,
      schemaDoc: (_graphql$description = graphql === null || graphql === void 0 ? void 0 : graphql.description) !== null && _graphql$description !== void 0 ? _graphql$description : description,
      listQueryName: graphql === null || graphql === void 0 ? void 0 : graphql.listQueryName,
      itemQueryName: graphql === null || graphql === void 0 ? void 0 : graphql.itemQueryName,
      hooks // FIXME: Unsupported options: Need to work which of these we want to support with backwards
      // compatibility options.
      // adminDoc
      // labelResolver
      // labelField
      // adminConfig
      // label
      // singular
      // plural
      // path
      // adapterConfig
      // cacheHint
      // plugins

    });
  });
  return keystone$1;
}

function createSystem(config, dotKeystonePath, script) {
  const keystone = createKeystone(config, dotKeystonePath, script);
  const graphQLSchema = createGraphQLSchema(config, keystone);
  const createContext = makeCreateContext({
    keystone,
    graphQLSchema
  });
  return {
    keystone,
    graphQLSchema,
    createContext
  };
}

/* Validate lists config and default the id field */

function applyIdFieldDefaults(config) {
  const lists = {};
  Object.keys(config.lists).forEach(key => {
    var _config$lists$key$idF, _idField$config$ui, _idField$config$ui2;

    const listConfig = config.lists[key];

    if (listConfig.fields.id) {
      throw new Error(`A field with the \`id\` path is defined in the fields object on the ${JSON.stringify(key)} list. This is not allowed, use the idField option instead.`);
    }

    let idField = (_config$lists$key$idF = config.lists[key].idField) !== null && _config$lists$key$idF !== void 0 ? _config$lists$key$idF : {
      mongoose: fields.mongoId({}),
      knex: fields.autoIncrement({}),
      prisma_postgresql: fields.autoIncrement({})
    }[config.db.adapter];
    idField = _objectSpread(_objectSpread({}, idField), {}, {
      config: _objectSpread({
        ui: _objectSpread({
          createView: _objectSpread({
            fieldMode: 'hidden'
          }, (_idField$config$ui = idField.config.ui) === null || _idField$config$ui === void 0 ? void 0 : _idField$config$ui.createView),
          itemView: _objectSpread({
            fieldMode: 'hidden'
          }, (_idField$config$ui2 = idField.config.ui) === null || _idField$config$ui2 === void 0 ? void 0 : _idField$config$ui2.itemView)
        }, idField.config.ui)
      }, idField.config)
    });

    const fields$1 = _objectSpread({
      id: idField
    }, listConfig.fields);

    lists[key] = _objectSpread(_objectSpread({}, listConfig), {}, {
      fields: fields$1
    });
  });
  return lists;
}

/*
  This function executes the validation and other initialisation logic that
  needs to be run on Keystone Config before it can be used.
*/

function initConfig(config) {
  return _objectSpread(_objectSpread({}, config), {}, {
    lists: applyIdFieldDefaults(config)
  });
}

exports.createKeystone = createKeystone;
exports.createSystem = createSystem;
exports.initConfig = initConfig;
