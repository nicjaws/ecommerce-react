'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var cookie = require('cookie');
var Iron = require('@hapi/iron');
var uidSafe = require('uid-safe');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var Iron__default = /*#__PURE__*/_interopDefault(Iron);

function generateSessionId() {
  return uidSafe.sync(24);
}

function asSessionStrategy(sessionStrategy) {
  return sessionStrategy;
}

const TOKEN_NAME = 'keystonejs-session';
const MAX_AGE = 60 * 60 * 8; // 8 hours
// should we also accept httpOnly?

/* TODO:
  - [ ] We could support additional where input to validate item sessions (e.g an isEnabled boolean)
*/
function withItemData(createSession, fieldSelections = {}) {
  return () => {
    const _createSession = createSession(),
          {
      get
    } = _createSession,
          sessionStrategy = _objectWithoutProperties(_createSession, ["get"]);

    return _objectSpread(_objectSpread({}, sessionStrategy), {}, {
      get: async ({
        req,
        createContext
      }) => {
        const session = await get({
          req,
          createContext
        });
        const sudoContext = createContext({
          skipAccessControl: true
        });

        if (!session || !session.listKey || !session.itemId || !sudoContext.lists[session.listKey]) {
          return;
        } // NOTE: This is wrapped in a try-catch block because a "not found" result will currently
        // throw; I think this needs to be reviewed, but for now this prevents a system crash when
        // the session item is invalid


        try {
          // If no field selection is specified, just load the id. We still load the item,
          // because doing so validates that it exists in the database
          const item = await sudoContext.lists[session.listKey].findOne({
            where: {
              id: session.itemId
            },
            resolveFields: fieldSelections[session.listKey] || 'id'
          }); // If there is no matching item found, return no session

          if (!item) {
            return;
          }

          return _objectSpread(_objectSpread({}, session), {}, {
            data: item
          });
        } catch (e) {
          // TODO: This swallows all errors, we need a way to differentiate between "not found" and
          // actual exceptions that should be thrown
          return;
        }
      }
    });
  };
}
function statelessSessions({
  secret,
  maxAge = MAX_AGE,
  path = '/',
  secure = process.env.NODE_ENV === 'production',
  ironOptions = Iron__default['default'].defaults
}) {
  return () => {
    if (!secret) {
      throw new Error('You must specify a session secret to use sessions');
    }

    if (secret.length < 32) {
      throw new Error('The session secret must be at least 32 characters long');
    }

    return asSessionStrategy({
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async get({
        req,
        createContext
      }) {
        if (!req.headers.cookie) return;
        let cookies = cookie.parse(req.headers.cookie);
        if (!cookies[TOKEN_NAME]) return;

        try {
          return await Iron__default['default'].unseal(cookies[TOKEN_NAME], secret, ironOptions);
        } catch (err) {}
      },

      async end({
        res
      }) {
        res.setHeader('Set-Cookie', cookie.serialize(TOKEN_NAME, '', {
          maxAge: 0,
          expires: new Date(),
          httpOnly: true,
          secure,
          path,
          sameSite: 'lax'
        }));
      },

      async start({
        res,
        data
      }) {
        let sealedData = await Iron__default['default'].seal(data, secret, _objectSpread(_objectSpread({}, ironOptions), {}, {
          ttl: maxAge * 1000
        }));
        res.setHeader('Set-Cookie', cookie.serialize(TOKEN_NAME, sealedData, {
          maxAge,
          expires: new Date(Date.now() + maxAge * 1000),
          httpOnly: true,
          secure,
          path,
          sameSite: 'lax'
        }));
        return sealedData;
      }

    });
  };
}
function storedSessions(_ref) {
  let {
    store: storeOption,
    maxAge = MAX_AGE
  } = _ref,
      statelessSessionsOptions = _objectWithoutProperties(_ref, ["store", "maxAge"]);

  return () => {
    let {
      get,
      start,
      end
    } = statelessSessions(_objectSpread(_objectSpread({}, statelessSessionsOptions), {}, {
      maxAge
    }))();
    let store = typeof storeOption === 'function' ? storeOption({
      maxAge
    }) : storeOption;
    return {
      connect: store.connect,
      disconnect: store.disconnect,

      async get({
        req,
        createContext
      }) {
        let sessionId = await get({
          req,
          createContext
        });

        if (typeof sessionId === 'string') {
          return store.get(sessionId);
        }
      },

      async start({
        res,
        data,
        createContext
      }) {
        let sessionId = generateSessionId();
        await store.set(sessionId, data);
        return (start === null || start === void 0 ? void 0 : start({
          res,
          data: {
            sessionId
          },
          createContext
        })) || '';
      },

      async end({
        req,
        res,
        createContext
      }) {
        let sessionId = await get({
          req,
          createContext
        });

        if (typeof sessionId === 'string') {
          await store.delete(sessionId);
        }

        await (end === null || end === void 0 ? void 0 : end({
          req,
          res,
          createContext
        }));
      }

    };
  };
}
/**
 * This is the function createSystem uses to implement the session strategy provided
 */

function implementSession(sessionStrategy) {
  let isConnected = false;
  return {
    async createSessionContext(req, res, createContext) {
      if (!isConnected) {
        var _sessionStrategy$conn;

        await ((_sessionStrategy$conn = sessionStrategy.connect) === null || _sessionStrategy$conn === void 0 ? void 0 : _sessionStrategy$conn.call(sessionStrategy));
        isConnected = true;
      }

      return {
        session: await sessionStrategy.get({
          req,
          createContext
        }),
        startSession: data => sessionStrategy.start({
          res,
          data,
          createContext
        }),
        endSession: () => sessionStrategy.end({
          req,
          res,
          createContext
        })
      };
    }

  };
}

exports.implementSession = implementSession;
exports.statelessSessions = statelessSessions;
exports.storedSessions = storedSessions;
exports.withItemData = withItemData;
